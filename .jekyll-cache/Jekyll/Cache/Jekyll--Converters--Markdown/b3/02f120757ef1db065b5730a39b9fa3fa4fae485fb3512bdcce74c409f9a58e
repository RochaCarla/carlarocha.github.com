I"™1<p><a href="/ruby-guide/">Voltar ao come√ßo do guia</a></p>

<p>At√© o momento, os programas que criamos foram escritos de forma a resolver um problema uma √∫nica vez. Mas e se quisermos resolver o mesmo problema duas vezes? Tr√™s vezes? Considere o programa que faz convers√£o de valores entre moedas do <a href="/ruby-guide/flow">cap√≠tulo anterior</a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="s2">"Digite o valor para ser convertido (em Real)"</span>
<span class="n">valor_para_converter</span> <span class="o">=</span> <span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span><span class="p">.</span><span class="nf">to_f</span>

<span class="nb">puts</span> <span class="s2">"Digite a moeda para converter (D para D√≥lar ou E para Euro)"</span>
<span class="n">moeda_para_converter</span> <span class="o">=</span> <span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span><span class="p">.</span><span class="nf">upcase</span>

<span class="k">if</span> <span class="n">moeda_para_converter</span> <span class="o">==</span> <span class="s2">"D"</span>
  <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>
  <span class="nb">puts</span> <span class="s2">"A convers√£o em dol√°r ser√°:"</span> <span class="p">,</span> <span class="p">(</span><span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span><span class="p">).</span><span class="nf">round</span>
<span class="k">else</span>
  <span class="n">cotacao_euro</span> <span class="o">=</span> <span class="mf">6.64</span>
  <span class="nb">puts</span> <span class="s2">"A convers√£o em euro ser√°:"</span><span class="p">,</span> <span class="p">(</span><span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span><span class="p">).</span><span class="nf">round</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Perceba que nesse exemplo, o valor da cota√ß√£o das moedas est√£o fixos no nosso c√≥digo, mas n√≥s sabemos que a cota√ß√£o √© flutuante, muda o tempo todo! E se quisessemos usar o servi√ßo do Google para</p>

<h2 id="fun√ß√µes">Fun√ß√µes</h2>

<p>Fun√ß√µes s√£o blocos de c√≥digo que englobam um determinado comportamento de forma que este seja reutilizado em outro local, sem necessidade de duplicar c√≥digo. C√≥digo duplicado, na realidade, √© um dos grandes problemas do desenvolvimento de software moderno. Fun√ß√µes com escopo bem definido s√£o s√£o excelentes para evitar c√≥digo duplicado. Ao longo desse guia n√≥s j√° utilizamos diversas fun√ß√µes como <code class="highlighter-rouge">puts</code>, <code class="highlighter-rouge">to_s</code>, <code class="highlighter-rouge">gets</code>, como muitas outras. Imagina se n√≥s precis√°ssemos escrever c√≥digo para imprimir texto na tela? Ou converter uma vari√°vel para string, ou para receber dados do usu√°rio? Que bom que j√° existem essas fun√ß√µes! N√≥s apenas reutilizamo-as. Reuso √© um termo chave em programa√ß√£o em geral e, em particular, quando falamos de fun√ß√µes. Como reveremos nesse cap√≠tulo, podemos resolver problemas mais complexos, compondo fun√ß√µes menores, bem definidas.</p>

<p>Para declarar um m√©todo em ruby, devemos seguir a seguinte estrutura:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">nome_da_funcao</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">algum_valor</span>
<span class="k">end</span>
</code></pre></div></div>

<p>H√° alguns conceitos-chave aqui. Primeiro, usamos a palavra reservada <code class="highlighter-rouge">def</code> para definir o in√≠cio de um m√©todo. De forma similar, a palavra reserva <code class="highlighter-rouge">end</code> define o fim de um m√©todo. Ap√≥s nomear o m√©todo (no caso do nosso exemplo, usamos o nome <code class="highlighter-rouge">nome_da_funcao</code>), temos a op√ß√£o de passar argumentos para o m√©todo. Op√ß√£o pois podemos criar fun√ß√µes sem argumentos. Argumentos s√£o vari√°veis que devem ser manipuladas dentro de um m√©todo. Mais concretamente, o m√©todo <code class="highlighter-rouge">puts</code> recebe como argumento uma <code class="highlighter-rouge">String</code> que ser√° impressa na tela (que s√£o passadas por par√™nteses <code class="highlighter-rouge">()</code><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>). No entanto, o m√©todo <code class="highlighter-rouge">gets</code> n√£o recebe nenhum argumento (n√£o passamos nada por par√™nteses <code class="highlighter-rouge">()</code> pra esse m√©todo).</p>

<p>O nome do m√©todo junto com seus argumentos s√£o tamb√©m conhecidos como a assinatura do m√©todo. A assinatura do m√©todo √© utilizada em v√°rios momentos pela linguagem, como por exemplo para resolu√ß√£o de nomes. Uma vez que diferentes fun√ß√µes podem ter o mesmo nome (lembra que <code class="highlighter-rouge">+</code> √© um m√©todo que existe tanto em <code class="highlighter-rouge">Integer</code>s e <code class="highlighter-rouge">String</code>s?), a linguagem de programa√ß√£o precisa saber exatamente qual m√©todo deve ser executada.</p>

<p>Um outro conceito importante √© o escopo do m√©todo. O escopo √© o contexto que delimita quais valores e express√µes que s√£o criados dentro de um m√©todo (entre um <code class="highlighter-rouge">def</code> e um <code class="highlighter-rouge">end</code>). Trechos de c√≥digo que s√£o definidos dentro do contexto de um m√©todo s√≥ s√£o vis√≠veis e execut√°veis dentro do m√©todo; ou seja, estes n√£o existem fora do m√©todo. Vamos observar isso no nosso programa abaixo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="p">(</span><span class="n">valor_para_converter</span><span class="p">)</span>
 <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>

 <span class="n">valor_convertido</span> <span class="o">=</span> <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>

 <span class="k">return</span> <span class="n">valor_convertido</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span>

<span class="nb">puts</span> <span class="n">valor_convertido</span>
</code></pre></div></div>

<p>Ao executar esse programa, √© impresso na tela o valor <code class="highlighter-rouge">17.825311942959</code> que √© o valor armazenado na vari√°vel <code class="highlighter-rouge">valor_convertido</code> e ap√≥s recebemos um <code class="highlighter-rouge">NameError (undefined local variable or method `valor_convertido' for main:Object)</code>.  Isso acontece pois a vari√°vel <code class="highlighter-rouge">valor_convertido</code> foi definida dentro do m√©todo <code class="highlighter-rouge">converter_para_dolar</code>, logo ela n√£o existe fora desta fun√ß√£o. No entanto, vari√°veis que definidas antes de um m√©todo podem ser utilizadas dentro de um m√©todo. Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>

<span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="p">(</span><span class="n">valor_para_converter</span><span class="p">)</span>
  <span class="n">valor_convertido</span> <span class="o">=</span> <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>
  <span class="k">return</span> <span class="n">valor_convertido</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span>
</code></pre></div></div>

<p>A vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> √© vis√≠vel dentro do m√©todo <code class="highlighter-rouge">converter_para_dolar</code> pois o escopo da vari√°vel √© global, ou seja, a vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> pode ser acessada de qualquer lugar do nosso programa. No entanto, vari√°veis definidas dentro do m√©todo s√≥ existem no escopo do m√©todo.</p>

<p>Por fim, antes de encerrar o m√©todo com um <code class="highlighter-rouge">end</code>, podemos no entanto retornar um valor, atrav√©s da palavra reservada <code class="highlighter-rouge">return</code>. O <code class="highlighter-rouge">return</code> deve obrigatoriamente ser a √∫ltima instru√ß√£o de um m√©todo. Caso exista alguma instru√ß√£o ap√≥s um <code class="highlighter-rouge">return</code>, esta instru√ß√£o n√£o √© executada. Vejamos no exemplo a seguir:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="p">(</span><span class="n">valor_para_converter</span><span class="p">)</span>
 <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>

 <span class="n">valor_convertido</span> <span class="o">=</span> <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>

 <span class="k">return</span> <span class="n">valor_convertido</span>
 <span class="nb">puts</span> <span class="s2">"O valor convertido √© "</span> <span class="o">+</span> <span class="n">valor_convertido</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div></div>

<p>Nesse caso, o m√©todo <code class="highlighter-rouge">puts</code> n√£o √© executada pois foi colocada ap√≥s o <code class="highlighter-rouge">return</code>. Como j√° vimos em outros locais nesse guia, Ruby √© uma linguagem que fornece v√°rios a√ß√∫cares sint√°ticos aos desenvolvedores. A opcionalidade dos par√™nteses √© um a√ß√∫car sint√°tico conhecido. Um outro exemplo de a√ß√∫car sint√°tico √© a opcionalidade do <code class="highlighter-rouge">return</code> ao fim de um m√©todo. Neste caso, a √∫ltima instru√ß√£o √© imediatamente retornada. Vejamos no exemplo a seguir:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span>
 <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>

 <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span>
</code></pre></div></div>

<p>No caso do exemplo acima, a √∫ltima instru√ß√£o √© a express√£o <code class="highlighter-rouge">valor_para_converter / cotacao_dolar</code>. O <code class="highlighter-rouge">return</code> impl√≠cito avaliar√° essa express√£o e retornar√° seu resultado. Sem os par√™nteses <code class="highlighter-rouge">()</code> (tanto na defini√ß√£o quanto no uso do m√©todo) e a aus√™ncia de um return deixaram o c√≥digo mais simples, mais conciso.</p>

<h2 id="fun√ß√µes-sem-nome">Fun√ß√µes sem nome</h2>

<h3 id="fun√ß√µes-ou-m√©todos-qual-a-diferen√ßa">Fun√ß√µes ou m√©todos? Qual a diferen√ßa?</h3>

<h2 id="escopo-de-vari√°veis">Escopo de vari√°veis</h2>

<p>O escopo √© o que define onde uma vari√°vel pode ser acessada. O escopo pode ser pequeno, a n√≠vel local, ou pode ser grande, a n√≠vel global.</p>

<p>https://stackoverflow.com/questions/11495098/difference-between-various-variables-scopes-in-ruby</p>

<p>https://www.techotopia.com/index.php/Ruby_Variable_Scope</p>

<p>https://www.rubyguides.com/2019/03/ruby-scope-binding/</p>

<ul>
  <li>Escreva a sua pr√≥pria fun√ß√£o que escreva c√≥digo na tela do usu√°rio, similar ao <code class="highlighter-rouge">puts</code>.</li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Como j√° discutimos em outros cap√≠tulos, os par√™nteses <code class="highlighter-rouge">()</code> s√£o opcionais tanto na defini√ß√£o quanto no uso de fun√ß√µes em Ruby.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET