I"“5<p><a href="/ruby-guide/">Voltar ao come√ßo do guia</a></p>

<p>Computadores n√£o entendem inteiros, strings, booleanos, ou objetos. Toda representa√ß√£o de tipos que vimos at√© aqui n√£o s√£o intelig√≠veis, do ponto de vista do computador.</p>

<p>Em algum momento, estas representa√ß√µes de mais alto n√≠vel precisam ser convertidas para uma representa√ß√£o de mais baixo n√≠vel; a √∫nica que o computador possa entender: o bin√°rio.</p>

<!-- Programas e dados compartilham o mesmo espa√ßo em uma fita e o computador ler um bit de cada vez nessa fita. Mas o que √© um bit? -->

<h2 id="bits-e-bytes">Bits e bytes</h2>

<p>O <em>bit</em> (do ingl√™s, <em>binary digit</em>) √© a menor forma de se representar dados em um computador. O bit pode ter somente um dos seguintes valores: 0 ou 1.</p>

<p>No entanto, como um bit tem somente duas representa√ß√µes, ele √© muito limitante. S√≥ conseguimos representar dois n√∫mero com um bit. Como fazemos para representar todos os outros n√∫meros?</p>

<h3 id="inteiros-em-bin√°rio">Inteiros em bin√°rio</h3>

<p>Podemos ir agrupando bits de forma a representar outros n√∫meros. Com dois bits, j√° poder√≠amos representar o n√∫mero dois (<code class="highlighter-rouge">10</code>) e o n√∫mero tr√™s (<code class="highlighter-rouge">11</code>). Vamos usar as opera√ß√µes abaixo para entender como isso seria poss√≠vel.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 10
10 + 1 = 11
</code></pre></div></div>

<p>A express√£o <code class="highlighter-rouge">1 + 1</code> em bin√°rio √© avaliada para <code class="highlighter-rouge">10</code> pois precisamos de dois bits para armazenar o n√∫mero <code class="highlighter-rouge">2</code>. Com tr√™s bits conseguimos representar o n√∫mero quatro (<code class="highlighter-rouge">100</code>), cinco (<code class="highlighter-rouge">101</code>), seis (<code class="highlighter-rouge">110</code>) e sete (<code class="highlighter-rouge">111</code>). Para representar o n√∫mero oito precisar√≠amos de quatro bits.</p>

<p>A medida que vamos acrescentando mais bits, conseguimos representar um quantidade maior de n√∫meros. Com oito bits j√° √© poss√≠vel armazenar 256 d√≠gitos (2^8 = 256).</p>

<!--Mas, ainda assim, estamos muito longe de armazenar um inteiro muito grande, como a massa da terra.  suficiente para representar os d√≠gitos de 0 at√© 9, todas as letras do alfabeto, e mais alguns caracteres especiais, como ```"!"```, ```"@"```, ou ```"#"```. -->

<p>Com tantos bits pra armazenar, facilitaria  nossa vida se tiv√©ssemos representa√ß√µes de mais alto n√≠vel pra armazena-los. A primeira representa√ß√£o mais alto n√≠vel de um bit √© o <em>byte</em>, um grupo de 8 bits. Embora pouco conhecido, um h√° tamb√©m um grupo de 4 bits, chamado <em>nibble</em>. Os mesmos d√≠gitos de 1 a 4 do exemplo acima poderiam ser representados como abaixo:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000 0000
0000 0001
0000 0010
0000 0011
</code></pre></div></div>

<p>Mas esses n√∫meros s√£o todos positivos. Como fazemos pra representar n√∫meros negativos?</p>

<p>Como sabemos, inteiros podem ser <em>signed</em> (com sinal) ou <em>unsigned</em>  (sem sinal). Inteiros de oito bytes sem sinal podem ser representados entre 0 a 256, enquanto que inteiros de oito bytes com sinal podem representar os n√∫meros de -127 a 128 (zero incluso). Nesse caso, representamos o sinal pelo bit mais significativo, que geralmente √© representado pelo primeiro dos oito bits. Se o primeiro bit for 0, o n√∫mero √© positivo; se for 1, o n√∫mero √© negativo. Por exemplo, o n√∫mero 15, em bin√°rio, √© representado como <code class="highlighter-rouge">1000 1111</code>.</p>

<h3 id="strings-em-bin√°rio">Strings em Bin√°rio</h3>

<p>Nesse momento torna-se f√°cil perceber que precisamos de muitos bits para armazenar dados ligeiramente mais complexos. Uma string como <code class="highlighter-rouge">"UFPA"</code> precisa de 32 bits para ser representada. Em Ruby, cada caracter de uma string precisa de 8 bits (ou um byte) para ser armazenado. Como a string <code class="highlighter-rouge">"UFPA"</code> tem quatro caracteres, precisamos de quatro bytes (ou 32 bits).</p>

<p>Logo, poder√≠amos generalizar que uma string de tamanho <em>n</em> ocupa <em>n</em> bytes?</p>

<p>Vamos responder com um exerc√≠cio: quantos bits precisamos pra armazenar a string <code class="highlighter-rouge">"Ol√° mundo"</code>? A string tem 9 caracteres, mas precisamos de 10 (!) bytes para representa-la. Rode a instru√ß√£o <code class="highlighter-rouge">"Ol√° mundo".bytesize</code> para checar voc√™ mesmo (o m√©todo <code class="highlighter-rouge">bytesize</code> conta a quantidade de bytes de uma string). Como pode?</p>

<p>Isso acontece pois caracteres como <code class="highlighter-rouge">"a"</code>, <code class="highlighter-rouge">"b"</code>, ou <code class="highlighter-rouge">"c"</code> necessitam de apenas um byte para serem representados (<code class="highlighter-rouge">"a".bytesize # =&gt; 1</code>), enquanto que caracteres especiais como o <code class="highlighter-rouge">"√ß"</code> do Portugu√™s e o <code class="highlighter-rouge">"¬ø"</code> do Espanhol precisaram de dois bytes para serem representados (<code class="highlighter-rouge">"√ß".bytesize # =&gt; 2</code>).</p>

<p>Agora sabemos que um charactere precisa de um byte para ser representado e caracteres especiais precisam de dois (ou mais) bytes. Mas como sabemos o bin√°rio dessa string? Podemos usar o m√©todo <code class="highlighter-rouge">"a".bytes</code>, que no caso da string <code class="highlighter-rouge">"a"</code> retorna <code class="highlighter-rouge">[97]</code>, ou seja, um array de um √∫nico elemento, o <code class="highlighter-rouge">97</code>. Mas o que seria esse n√∫mero 97? Vamos testar com outros caracteres.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"a"</span><span class="p">.</span><span class="nf">bytes</span>   <span class="c1"># =&gt; [97]</span>
<span class="s2">"b"</span><span class="p">.</span><span class="nf">bytes</span>   <span class="c1"># =&gt; [98]</span>
<span class="s2">"c"</span><span class="p">.</span><span class="nf">bytes</span>   <span class="c1"># =&gt; [99]</span>
<span class="s2">"d"</span><span class="p">.</span><span class="nf">bytes</span>   <span class="c1"># =&gt; [100]</span>

<span class="s2">"A"</span><span class="p">.</span><span class="nf">bytes</span>   <span class="c1"># =&gt; [65]</span>
<span class="s2">"B"</span><span class="p">.</span><span class="nf">bytes</span>   <span class="c1"># =&gt; [66]</span>
<span class="s2">"C"</span><span class="p">.</span><span class="nf">bytes</span>   <span class="c1"># =&gt; [67]</span>
<span class="s2">"D"</span><span class="p">.</span><span class="nf">bytes</span>   <span class="c1"># =&gt; [68]</span>
</code></pre></div></div>

<p>Cada caracter √© representado por um c√≥digo de um byte (ou oito bits) diferente e, aparentemente, estes c√≥digos seguem uma determinada ordem. Os caracteres tamb√©m s√£o diferenciados entre mai√∫sculos e min√∫sculos. Curiosamente, os caracteres mai√∫sculos s√£o representados com c√≥digos menores que os caracteres min√∫sculos. Cada caracter retorna um c√≥digo diferente. Por exemplo, <code class="highlighter-rouge">"a"</code> retorna <code class="highlighter-rouge">[97]</code> enquanto que <code class="highlighter-rouge">"b"</code> retorna <code class="highlighter-rouge">[98]</code>. Por hora, vamos abstrair os colchetes (<code class="highlighter-rouge">[]</code>) e focar nos c√≥digos.</p>

<p>Mas que c√≥digos s√£o esses?</p>

<p>Estes c√≥digos adv√™m de uma tabela de convers√£o, no caso, a famosa <a href="https://en.wikipedia.org/wiki/ASCII">tabela ASCII</a> (abrevia√ß√£o de <em>American Standard Code for Information Interchange</em>). A tabela ASCII foi inicialmente desenvolvida para trabalhar com 7 bits (ou 2^7 = 128). Embora suficiente para √©poca (d√©cada de 70), essa tabela deixava de fora v√°rios caracteres especiais, como o <code class="highlighter-rouge">"√ß"</code> e o <code class="highlighter-rouge">"¬ø"</code>,que j√° mencionamos anteriormente.</p>

<hr />
<p><strong>Curiosidade</strong></p>

<p>Na √©poca da sua cria√ß√£o, 7 bits eram suficiente para armazenar muitos dos principais caracteres necess√°rios da l√≠ngua inglesa com folga (mais exatamente, 1 bit de folga). Esse 1 bit de folga fez com que localidades que n√£o tinham todo seu alfabeto contemplado pela tabela ASCII (Portugu√™s e o Espanho, j√° mencionados, mas tamb√©m o Chin√™s, Grego, √Årabe, dentre tantos outros) criassem seu pr√≥prio mapa de caracteres. A consequ√™ncia? Esse 1 bit extra resultou em dezenas de varia√ß√µes de mapas de c√≥digo. N√£o √© necess√°rio mencionar que essa diversidade de mapas de c√≥digo criou uma verdadeira dor de cabe√ßa para internacionaliza√ß√£o de textos que necessitam de mais de uma tabela de convers√£o. Uma das primeiras tentativas de organizar essa bagun√ßa foi o Unicode, tanto que hoje em dia, utilizamos unicode para representar textos humanamente leg√≠veis. Mas isso √© assunto pra outro guia.</p>

<hr />

<p>Os c√≥digos de retorno do m√©todo <code class="highlighter-rouge">bytes</code> s√£o, na realidade, a representa√ß√£o decimal de um determinado bin√°rio. Por exemplo, o c√≥digo <code class="highlighter-rouge">97</code> √© a representa√ß√£o decimal para o bin√°rio <code class="highlighter-rouge">01100001</code>, enquanto o c√≥digo <code class="highlighter-rouge">98</code> √© a representa√ß√£o decimal para o bin√°rio <code class="highlighter-rouge">01100010</code>, e assim por diante.</p>

<p>Esse processo de tradu√ß√£o caracter -&gt; c√≥digo -&gt; bin√°rio √© chamado de <em>encoding</em>. H√° diversos tipos de <em>encoding</em>; um caracter com um byte em um determinado <em>encoding</em> pode ter dois ou mais em outro. Encodings de um byte por caracter s√£o extremamente limitados (e, como vimos na caixa acima, tamb√©m causam boa dor de cabe√ßa), mas encodings de dois bytes (16 bits) j√° s√£o mais plausiveis, pois podem representar 2^16 (65.536) caracteres. Em Unicode, temos UTF-8 (que representam 8 bits por caracter) e o UTF-16 (que representam 16 bits por caracter). Embora utilizar mais bytes por caracter resolva o problema da representa√ß√£o de caracteres de localidades espec√≠ficas (pense nos s√≠mbolos Japoneses), eles aumentam a chance de desperd√≠cio de espa√ßo em arquivos de texto.</p>

<p>At√© agora estamos fazendo tradu√ß√£o de caracter por caracter, mas a tradu√ß√£o de textos mais longos seguem o mesmo racioc√≠nio. A express√£o <code class="highlighter-rouge">"UFPA".bytes</code> √© avaliada para <code class="highlighter-rouge">[85, 70, 80, 65]</code>, que nada mais √© do que um array em que cada posi√ß√£o √© a representa√ß√£o decimal de cada caracter da string <code class="highlighter-rouge">"UFPA"</code>.</p>

<h2 id="por-que-01--02--03">Por que 0.1 + 0.2 != 0.3?</h2>

<p>Entendemos como representar n√∫meros inteiros e strings em bin√°rio, mas como poder√≠amos representar n√∫meros com ponto flutuante?</p>

<p>Caso estejamos trabalhando com moeda (sal√°rio, impostos, valores de porudo), em que o n√∫mero de casa decimais √© pequeno e conhecido, basta transformar o n√∫mero fracionado para inteiro (multiplicando por <code class="highlighter-rouge">100</code>) e, ap√≥s a opera√ß√£o, transformar de volta para a fra√ß√£o (dividindo por <code class="highlighter-rouge">100</code>). A principal vantagem dessa abordagem √© a rapidez, pois o hardware tem circuitos para lidar com n√∫meros inteiros. No entanto, essa abordagem tem pouca precis√£o. Mas poucas pessoas se queixam de 0.001 faltando no troco. Esta baixa precis√£o se torna um problema, por exemplo, em aplica√ß√µes matem√°ticas que fazem uso de n√∫meros irracionais como o PI (3.141592‚Ä¶).</p>

<p>O PI √© diferente de outros n√∫mero irracionais, como o resultado da divis√£o <code class="highlighter-rouge">1/3</code>, o qual se conhece os decimais, mas n√£o se sabe quantos s√£o. No PI n√£o se conhece (todos) os decimais, e estes tamb√©m n√£o seguem nenhum padr√£o. Tamb√©m n√£o faz sentido armazenar o n√∫mero PI na mem√≥ria. Simplesmente n√£o temos mem√≥ria pra isso. O que poder√≠amos fazer ent√£o?</p>

<h2 id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de fixa√ß√£o</h2>

<ul>
  <li>
    <p>Qual sistema de <em>encoding</em> o seu sistema operacional utiliza. Qual a capacidade de representa√ß√£o desse <em>encoding</em>?</p>
  </li>
  <li>
    <p>Qual a capacidade de representa√ß√£o do nintendinho?</p>
  </li>
  <li>
    <p>Estude sobre como funciona algorimos de ordena√ß√£o de palavras em Chin√™s.</p>
  </li>
  <li>
    <p>Explique por que a express√£o <code class="highlighter-rouge">"A" &gt; "a"</code> √© avaliada para <code class="highlighter-rouge">false</code>.</p>
  </li>
  <li>
    <p>Por qual raz√£o algumas linguagens de programa√ß√£o fornecem diveros tipos inteiros primitivos, como byte, short, int, ou long?</p>
  </li>
  <li>
    <p>Em Ruby n√£o existe tipos num√©ricos espec√≠ficos por√©m de tamanho vari√°vel. Por que isso acontece?</p>
  </li>
  <li>
    <p>Fa√ßa um programa em C que calcule o produt√≥rio um array com 2^16 elementos e retorne o tempo da opera√ß√£o. Fa√ßa implementa√ß√µes com elementos do tipo byte, short, int e long.</p>
  </li>
  <li>
    <p>Descreva o passo a passo da subtra√ß√£o bin√°ria da express√£o <code class="highlighter-rouge">15 - 5</code>. Pesquise sobre ‚ÄúTwo‚Äôs complement‚Äù.</p>
  </li>
  <li>
    <p>Crie um programa para fazer convers√£o de um n√∫mero float qualquer para sua forma bin√°ria em Ruby. Explique cada pequeno passo do seu programa.</p>
  </li>
</ul>
:ET