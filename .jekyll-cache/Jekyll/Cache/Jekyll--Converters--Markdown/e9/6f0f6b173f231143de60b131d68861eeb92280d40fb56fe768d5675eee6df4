I"Ÿ.<p><a href="/ruby-guide/">Voltar ao come√ßo do guia</a>.</p>

<p>Hashes s√£o tipos de dados que s√£o capazes de armazenar grupos de elementos, assim como um Array. Hashes, na verdade, s√£o constru√≠dos com base em Arrays, logo muito do que aprendemos em Arrays pode ser reaproveitado para utiliza√ß√£o de Hashes.</p>

<p>Diferente de um Array, no entanto, Hashes s√£o mais sofisticados e tem melhor desempenho em v√°rias opera√ß√µes. Vamos discutir mais a frente alguns desses casos. Uma outra caracter√≠stica de um hash √© o uso de chaves (<code class="highlighter-rouge">{}</code>) para delimitar seu escopo.</p>

<h3 id="criando-hashes">Criando hashes</h3>

<p>Podemos criar um Hash vazio usando a nota√ß√£o de chaves:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="p">{}</span>          <span class="c1"># =&gt; {}</span>
<span class="n">meu_hash</span> <span class="o">=</span> <span class="p">{}</span>    <span class="c1"># =&gt; {}</span>
</code></pre></div></div>

<p>Hashes s√£o tipos de dados que al√©m de um valor, armazenam tamb√©m uma chave. A chave √© utilizada para buscar o valor armazenado. Podemos definir um Hash em ruby usando a nota√ß√£o <code class="highlighter-rouge">{chave =&gt; valor}</code>. O s√≠mbolo <code class="highlighter-rouge">=&gt;</code> (hash rockets) separa a defini√ß√£o de chave e valor. Veja a seguir:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="s2">"um"</span> <span class="o">=&gt;</span> <span class="s2">"one"</span><span class="p">,</span> <span class="s2">"dois"</span> <span class="o">=&gt;</span> <span class="s2">"two"</span><span class="p">,</span> <span class="s2">"tr√™s"</span> <span class="o">=&gt;</span> <span class="s2">"three"</span><span class="p">}</span>
</code></pre></div></div>

<p>Nesse hash temos tr√™s pares de chave e valor. Isto significa que temos tr√™s chaves (<code class="highlighter-rouge">um</code>, <code class="highlighter-rouge">dois</code> e <code class="highlighter-rouge">tr√™s</code>) que podem ser utilizadas pra acessar tr√™s valores (<code class="highlighter-rouge">one</code>, <code class="highlighter-rouge">two</code> e <code class="highlighter-rouge">three</code>). A chave (que marca a posi√ß√£o) aparece ao lado esquedo do <code class="highlighter-rouge">=&gt;</code>, enquanto que o valor aparece ao lado direito.</p>

<p>Percba que a ideia de chave √© que ela seja capaz de referenciar um determinado valor dentro de um Hash. Logo, n√£o podem existir duas chaves iguais; do contr√°rio, como poder√≠amos recuperar o valor associado? Todavia, podemos ter o mesmo valor para duas chaves diferentes.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">chaves_duplicadas</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"um"</span> <span class="o">=&gt;</span> <span class="s2">"one"</span><span class="p">,</span> <span class="s2">"dois"</span> <span class="o">=&gt;</span> <span class="s2">"two"</span><span class="p">,</span> <span class="s2">"um"</span> <span class="o">=&gt;</span> <span class="s2">"ten"</span><span class="p">}</span>
<span class="nb">puts</span> <span class="n">chaves_duplicadas</span> <span class="c1"># =&gt; {"um"=&gt;"ten", "dois"=&gt;"two"}</span>

<span class="n">valores_duplicados</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"um"</span> <span class="o">=&gt;</span> <span class="s2">"one"</span><span class="p">,</span> <span class="s2">"dois"</span> <span class="o">=&gt;</span> <span class="s2">"two"</span><span class="p">,</span> <span class="s2">"tr√™s"</span> <span class="o">=&gt;</span> <span class="s2">"two"</span><span class="p">}</span>
<span class="nb">puts</span> <span class="n">valores_duplicados</span> <span class="c1"># =&gt; {"um"=&gt;"one", "dois"=&gt;"two", "tr√™s"=&gt;"two"}</span>
</code></pre></div></div>

<p>Como j√° √© de se imaginar, h√° v√°rias outras formas de se criar um Hash em Ruby. Uma das quais √© utilizando a orienta√ß√£o a objetos:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span>         <span class="c1"># =&gt; {}</span>
<span class="nb">puts</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="o">==</span> <span class="p">{}</span>   <span class="c1"># =&gt; true</span>

<span class="nb">puts</span> <span class="no">Hash</span><span class="p">[</span><span class="s2">"um"</span> <span class="o">=&gt;</span> <span class="s2">"one"</span><span class="p">]</span>   <span class="c1"># =&gt; {"um" =&gt; "one"}w</span>
</code></pre></div></div>

<p>Nos dois exemplos anteriores, criamos um Hash de strings como chave e valor. No entanto, assim como Arrays, podemos criar Hashes com tipos de dados diferentes, como no exemplo abaixo.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dados_pessoais</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">"nome"</span> <span class="o">=&gt;</span> <span class="s2">"Gustavo Pinto"</span><span class="p">,</span>
  <span class="s2">"cpf"</span> <span class="o">=&gt;</span> <span class="mo">00011122233</span><span class="p">,</span>
  <span class="s2">"telefones"</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"(91) 99052-0000"</span><span class="p">,</span> <span class="s2">"(91) 99052-0001"</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note que podemos inclusive usar Arrays como valores de um Hash. No entanto, embora estamo utilizando Strings para as chaves, Symbols s√£o mais comumente utilizados para este prop√≥sito, pois s√≠mbolos s√£o imut√°veis (e, como vimos acima, chaves n√£o podem ser publicadas). Vamos refatorar nosso Array para usar Symbols como chave:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dados_pessoais</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">:nome</span> <span class="o">=&gt;</span> <span class="s2">"Gustavo Pinto"</span><span class="p">,</span>
  <span class="ss">:cpf</span> <span class="o">=&gt;</span> <span class="mo">00011122233</span><span class="p">,</span>
  <span class="ss">:telefones</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"(91) 99052-0000"</span><span class="p">,</span> <span class="s2">"(91) 99052-0001"</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="manipulando-arrays">Manipulando arrays</h3>

<p>Para acessar uma determinada chave em um Hash, usamos a mesma nota√ß√£o de colchetes que usamos em Arrays:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dados_pessoais</span> <span class="o">=</span> <span class="c1"># ...</span>

<span class="nb">puts</span> <span class="n">dados_pessoais</span><span class="p">[</span><span class="ss">:nome</span><span class="p">]</span>      <span class="c1"># =&gt; "Gustavo Pinto"</span>
<span class="nb">puts</span> <span class="n">dados_pessoais</span><span class="p">[</span><span class="ss">:rg</span><span class="p">]</span>        <span class="c1"># =&gt; nil</span>
</code></pre></div></div>

<p>Voc√™ consegue perceber o que est√° acontecendo? A instru√ß√£o <code class="highlighter-rouge">dados_pessoais[:nome]</code> busca no Hash por uma chave chamada <code class="highlighter-rouge">:nome</code>. Ao encontrar essa chave, o Hash devolve o valor associado a esta chave, no caso, a String <code class="highlighter-rouge">Gustavo Pinto</code>. Essa String √© ent√£o enviada para o m√©todo <code class="highlighter-rouge">puts</code> que imprime na tela o resultado.</p>

<p>Assim como nos Arrays, em que um acesso a uma posi√ß√£o inexistente retorna um <code class="highlighter-rouge">nil</code>, em Hash, tentar acessar uma chave inexistente tamb√©m retorna um <code class="highlighter-rouge">nil</code>.</p>

<p>Para atribuir um valor a um Hash j√° existente, podemos usar o mesmo mecanismo de atribui√ß√£o. Por exemplo: <code class="highlighter-rouge">dados_pessoais[:nome] = "Gustavo Henrique"</code>. Caso a chave informada n√£o exista no Hash, um novo registro √© criado. Dessa forma, podemos popular um Hash da seguinte forma:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">livros</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">livros</span><span class="p">[</span><span class="ss">:sapiens</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Sapiens: A Brief History of Humankind"</span>
<span class="n">livros</span><span class="p">[</span><span class="ss">:mindset</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Mindset: The New Psychology of Success"</span>
<span class="n">livros</span><span class="p">[</span><span class="ss">:metrics</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"The tyranny of Metrics"</span>
</code></pre></div></div>

<p>Por fim, para encerrar nosso processo de manipula√ß√£o de um Hash, falta a capacidade de remover elementos. Hashes possuem o m√©todo <code class="highlighter-rouge">delete</code>, para que possamos remover valores com base em uma chave. Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">livros</span> <span class="o">=</span> <span class="c1"># ...</span>

<span class="n">livros</span><span class="p">.</span><span class="nf">delete</span> <span class="p">[</span><span class="ss">:metrics</span><span class="p">]</span>    <span class="c1"># =&gt; nil</span>
<span class="n">livros</span><span class="p">.</span><span class="nf">delete</span> <span class="ss">:metrics</span>      <span class="c1"># =&gt; "The tyranny of Metrics"</span>
</code></pre></div></div>

<p>Algo interessante aconteceu. Por que a primeira chamada ao <code class="highlighter-rouge">delete</code> retornou <code class="highlighter-rouge">nil</code> enquanto que a segunda chamada retornou o nome do livro. Em primeiro lugar, devemos saber que o m√©todo <code class="highlighter-rouge">delete</code> ele remove do Hash e retorna o valor removido. Logo, √© por isso que o valor removido √© impresso na tela. Mas por que a primeira chamada retorna <code class="highlighter-rouge">nil</code>?  Isso acontece pois estamos passando por par√¢metro um Array de um √∫nico elemento como chave (<code class="highlighter-rouge">[:metrics]</code>), e esta chave , e no Hash que n√≥s criamos n√£o h√° nenhuma chave com</p>

<p>. Por exemplo, em um Array, para remover um elemento que n√£o conhecemos, precisamos percorrer todo o Array at√© encontra-lo. Em um Hash, isso fazemos buscas usando uma <em>chave</em>.</p>

<p>At√© o Ruby 1.8, a nota√ß√£o de hash rockets (<code class="highlighter-rouge">=&gt;</code>) era a padr√£o para cria√ß√£o de hashes. No entanto, no Ruby 1.9, foi introduzida a nota√ß√£o de dois pontos (<code class="highlighter-rouge">:</code>). A nota√ß√£o de dois pontos tinha dois objetivos principais: um era tornar os Hashes sintaticamente mais pr√≥ximos de um JSON. A nota√ß√£o de dois pontos tamb√©m era mais f√°cil de ser utilizada. Nas atuais vers√µes de Ruby (vers√£o 3.0 inclu√≠da), ambas as nota√ß√µes de <code class="highlighter-rouge">=&gt;</code> e <code class="highlighter-rouge">:</code> s√£o v√°lidas para criar Hashes. Mas h√° um problema.</p>

<p>http://ruby-for-beginners.rubymonstas.org/built_in_classes/hashes.html</p>
:ET