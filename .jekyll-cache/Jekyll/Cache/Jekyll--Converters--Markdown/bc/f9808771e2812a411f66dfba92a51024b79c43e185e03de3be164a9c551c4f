I"ä<p><a href="/ruby-guide/">Voltar ao come√ßo do guia</a></p>

<p>At√© o momento, os programas que criamos foram escritos de forma a resolver um problema uma √∫nica vez. Mas e se quisermos resolver o mesmo problema duas vezes? Tr√™s vezes? Temos que escrever novamente o mesmo c√≥digo?</p>

<p>Considere o programa que faz convers√£o de valores entre moedas do <a href="/ruby-guide/flow">cap√≠tulo anterior</a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">puts</span> <span class="s2">"Digite o valor para ser convertido (em Real)"</span>
<span class="n">valor_para_converter</span> <span class="o">=</span> <span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span><span class="p">.</span><span class="nf">to_f</span>

<span class="nb">puts</span> <span class="s2">"Digite a moeda para converter (D para D√≥lar ou E para Euro)"</span>
<span class="n">moeda_para_converter</span> <span class="o">=</span> <span class="nb">gets</span><span class="p">.</span><span class="nf">chomp</span><span class="p">.</span><span class="nf">upcase</span>

<span class="k">if</span> <span class="n">moeda_para_converter</span> <span class="o">==</span> <span class="s2">"D"</span>
  <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>
  <span class="nb">puts</span> <span class="s2">"A convers√£o em dol√°r ser√°:"</span> <span class="p">,</span> <span class="p">(</span><span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span><span class="p">).</span><span class="nf">round</span>
<span class="k">else</span>
  <span class="n">cotacao_euro</span> <span class="o">=</span> <span class="mf">6.64</span>
  <span class="nb">puts</span> <span class="s2">"A convers√£o em euro ser√°:"</span><span class="p">,</span> <span class="p">(</span><span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span><span class="p">).</span><span class="nf">round</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Perceba que nesse exemplo, o valor da cota√ß√£o das moedas est√£o fixos no nosso c√≥digo, mas n√≥s sabemos que a cota√ß√£o √© flutuante, muda o tempo todo! E se quis√©ssemos usar o servi√ßo do Google para</p>

<h2 id="m√©todos">M√©todos</h2>

<p>M√©todos s√£o blocos de c√≥digo que englobam um determinado comportamento de forma que este seja reutilizado em outro local, evitando c√≥digo duplicado. C√≥digo duplicado, na realidade, √© um dos grandes problemas do desenvolvimento de software moderno. M√©todos com escopo bem definido s√£o s√£o excelentes para evitar c√≥digo duplicado. Ao longo desse guia n√≥s j√° utilizamos diversas m√©todos como <code class="highlighter-rouge">puts</code>, <code class="highlighter-rouge">to_s</code>, <code class="highlighter-rouge">gets</code>, como muitas outras. Imagina se n√≥s precis√°ssemos escrever c√≥digo para imprimir texto na tela? Ou converter uma vari√°vel para string, ou para receber dados do usu√°rio? Que bom que j√° existem essas m√©todos! N√≥s apenas reutilizamo-as. Reuso √© um termo chave em programa√ß√£o em geral e, em particular, quando falamos de m√©todos. Como reveremos nesse cap√≠tulo, podemos resolver problemas mais complexos, compondo m√©todos menores, bem definidas.</p>

<h2 id="defini√ß√£o-de-m√©todos">Defini√ß√£o de m√©todos</h2>

<p>Para declarar um m√©todo em ruby, devemos seguir a seguinte estrutura:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">nome_da_funcao</span> <span class="p">(</span><span class="n">argumentos</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">algum_valor</span>
<span class="k">end</span>
</code></pre></div></div>

<p>H√° alguns conceitos-chave aqui. Primeiro, usamos a palavra reservada <code class="highlighter-rouge">def</code> para definir o in√≠cio de um m√©todo. De forma similar, a palavra reserva <code class="highlighter-rouge">end</code> define o fim de um m√©todo. Ap√≥s nomear o m√©todo (no caso do nosso exemplo, usamos o nome <code class="highlighter-rouge">nome_da_funcao</code>), temos a op√ß√£o de passar argumentos para o m√©todo. Op√ß√£o pois podemos criar m√©todos sem argumentos. Argumentos s√£o vari√°veis que devem ser manipuladas dentro de um m√©todo. Mais concretamente, o m√©todo <code class="highlighter-rouge">puts</code> recebe como argumento uma <code class="highlighter-rouge">String</code> que ser√° impressa na tela (que s√£o passadas por par√™nteses <code class="highlighter-rouge">()</code><sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>). No entanto, o m√©todo <code class="highlighter-rouge">gets</code> n√£o recebe nenhum argumento (n√£o passamos nada por par√™nteses <code class="highlighter-rouge">()</code> pra esse m√©todo).</p>

<p>O nome do m√©todo junto com seus argumentos s√£o tamb√©m conhecidos como a assinatura do m√©todo. A assinatura do m√©todo √© utilizada em v√°rios momentos pela linguagem, como por exemplo para resolu√ß√£o de nomes. Uma vez que diferentes m√©todos podem ter o mesmo nome (lembra que <code class="highlighter-rouge">+</code> √© um m√©todo que existe tanto em <code class="highlighter-rouge">Integer</code>s e <code class="highlighter-rouge">String</code>s?), a linguagem de programa√ß√£o precisa saber exatamente qual m√©todo deve ser executado.</p>

<p>Um outro conceito importante √© o escopo do m√©todo. O escopo √© o contexto que delimita quais valores e express√µes que s√£o criados dentro de um m√©todo (entre um <code class="highlighter-rouge">def</code> e um <code class="highlighter-rouge">end</code>). Trechos de c√≥digo que s√£o definidos dentro do contexto de um m√©todo s√≥ s√£o vis√≠veis e execut√°veis dentro do m√©todo; ou seja, estes n√£o existem fora do m√©todo. Vamos observar isso no nosso programa abaixo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="p">(</span><span class="n">valor_para_converter</span><span class="p">)</span>
 <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>

 <span class="n">valor_convertido</span> <span class="o">=</span> <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>

 <span class="k">return</span> <span class="n">valor_convertido</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span>

<span class="nb">puts</span> <span class="n">valor_convertido</span>
</code></pre></div></div>

<p>Ao executar esse programa, √© impresso na tela o valor <code class="highlighter-rouge">17.825311942959</code> que √© o valor armazenado na vari√°vel <code class="highlighter-rouge">valor_convertido</code> e ap√≥s recebemos um <code class="highlighter-rouge">NameError (undefined local variable or method `valor_convertido' for main:Object)</code>.  Isso acontece pois a vari√°vel <code class="highlighter-rouge">valor_convertido</code> foi definida dentro do m√©todo <code class="highlighter-rouge">converter_para_dolar</code>, logo ela n√£o existe fora deste m√©todo. No entanto, vari√°veis que definidas antes de um m√©todo podem ser utilizadas dentro de um m√©todo. Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>

<span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="p">(</span><span class="n">valor_para_converter</span><span class="p">)</span>
  <span class="n">valor_convertido</span> <span class="o">=</span> <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>
  <span class="k">return</span> <span class="n">valor_convertido</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span>
</code></pre></div></div>

<p>A vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> √© vis√≠vel dentro do m√©todo <code class="highlighter-rouge">converter_para_dolar</code> pois o escopo da vari√°vel √© global, ou seja, a vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> pode ser acessada de qualquer lugar do nosso programa. No entanto, vari√°veis definidas dentro do m√©todo s√≥ existem no escopo do m√©todo.</p>

<p>Por fim, antes de encerrar o m√©todo com um <code class="highlighter-rouge">end</code>, podemos no entanto retornar um valor, atrav√©s da palavra reservada <code class="highlighter-rouge">return</code>. O <code class="highlighter-rouge">return</code> deve obrigatoriamente ser a √∫ltima instru√ß√£o de um m√©todo. Caso exista alguma instru√ß√£o ap√≥s um <code class="highlighter-rouge">return</code>, esta instru√ß√£o n√£o √© executada. Vejamos no exemplo a seguir:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="p">(</span><span class="n">valor_para_converter</span><span class="p">)</span>
 <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>

 <span class="n">valor_convertido</span> <span class="o">=</span> <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>

 <span class="k">return</span> <span class="n">valor_convertido</span>
 <span class="nb">puts</span> <span class="s2">"O valor convertido √© "</span> <span class="o">+</span> <span class="n">valor_convertido</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div></div>

<p>Nesse caso, o m√©todo <code class="highlighter-rouge">puts</code> n√£o √© executada pois foi colocada ap√≥s o <code class="highlighter-rouge">return</code>. Como j√° vimos em outros locais nesse guia, Ruby √© uma linguagem que fornece v√°rios a√ß√∫cares sint√°ticos aos desenvolvedores. A opcionalidade dos par√™nteses √© um a√ß√∫car sint√°tico conhecido. Um outro exemplo de a√ß√∫car sint√°tico √© a opcionalidade do <code class="highlighter-rouge">return</code> ao fim de um m√©todo. Neste caso, a √∫ltima instru√ß√£o √© imediatamente retornada. Vejamos no exemplo a seguir:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span>
 <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>

 <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span>
</code></pre></div></div>

<p>No caso do exemplo acima, a √∫ltima instru√ß√£o √© a express√£o <code class="highlighter-rouge">valor_para_converter / cotacao_dolar</code>. O <code class="highlighter-rouge">return</code> impl√≠cito avaliar√° essa express√£o e retornar√° seu resultado. Sem os par√™nteses <code class="highlighter-rouge">()</code> (tanto na defini√ß√£o quanto no uso do m√©todo) e a aus√™ncia de um return deixaram o c√≥digo mais simples, mais conciso.</p>

<h2 id="escopo-de-vari√°veis">Escopo de vari√°veis</h2>

<p>Escopo de uma vari√°vel se refere ao tempo de vida em que a vari√°vel vai estar vis√≠vel em um programa. Vari√°veis que s√£o ditas como fora de escopo n√£o s√£o vis√≠veis, logo n√£o podem ser manipuladas. De maneira geral, existem dois tipos de  escopos: o <strong>escopo local</strong>, em que a vari√°vel s√≥ pode ser acessada dentro de um m√©todo, e o <strong>escopo global</strong>, em que a vari√°vel pode ser acessada em qualquer lugar do programa, inclusive dentro de um m√©todo. Considere o exemplo anterior novamente:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span>
 <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>
 <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">cotacao_dolar</span>
</code></pre></div></div>

<p>O c√≥digo acima retorna um <code class="highlighter-rouge">NameError</code>, pois a vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> n√£o √© vis√≠vel fora do m√©todo que foi definida. Podemos usar a palavra reservada <code class="highlighter-rouge">defined?</code> para entender um pouco mais do escopo da vari√°vel. Vamos mudar um pouco o nosso exemplo anterior pra entender um pouco mais sobre os escopos das vari√°veis.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>
<span class="k">defined?</span> <span class="n">cotacao_dolar</span> <span class="c1"># =&gt; "local-variable"</span>

<span class="k">def</span> <span class="nf">converter_para_dolar</span>
 <span class="n">cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>
 <span class="k">defined?</span> <span class="n">cotacao_dolar</span> <span class="c1"># =&gt; "local-variable"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>No exemplo acima, tanto a vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> definida fora do m√©todo quanto a vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> definida dento do m√©todo tem escopo local. De fato, embora as vari√°veis tenham o mesmo nome, estas s√£o duas vari√°veis diferentes.</p>

<p>De forma similar, uma vari√°vel declarada fora do m√©todo <code class="highlighter-rouge">converter_para_dolar</code> tamb√©m n√£o poderia ser acessada dentro do m√©todo. Por√©m, e se quis√©ssemos extrair a vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> para fora do m√©todo, e assim utiliz√°ssemos em outros m√©todos? Nesse caso, ter√≠amos que mudar o escopo da vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> para global. Em Ruby, vari√°veis globais come√ßam com o s√≠mbolo <code class="highlighter-rouge">$</code>. Poder√≠amos alterar o nosso exemplo anterior da seguinte forma:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>
<span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span>
 <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="vg">$cotacao_dolar</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span>
</code></pre></div></div>

<p>Perceba que tivemos que alterar tanto na defini√ß√£o quanto no uso da vari√°vel <code class="highlighter-rouge">$cotacao_dolar</code>. No entanto, grandes poderes requerem grandes responsabilidades. Vari√°veis globais tornam a compreens√£o de c√≥digo mais dif√≠cil. Ao tornar uma vari√°vel global, qualquer m√©todo na sua aplica√ß√£o ganha acesso para manipular tais vari√°veis. Isso dificulta entendimento e depura√ß√£o de c√≥digo, uma vez que se faz necess√°rio investigar <em>todos</em> os m√©todos que fazem uso de vari√°veis globais.</p>

<p>Por fim, perceba tamb√©m que podemos confirmar a mudan√ßa do escopo usando novamente o comando <code class="highlighter-rouge">defined?</code>, como abaixo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vg">$cotacao_dolar</span> <span class="o">=</span> <span class="mf">5.61</span>
<span class="k">defined?</span> <span class="vg">$cotacao_dolar</span>  <span class="o">=&gt;</span> <span class="s2">"global-variable"</span>
</code></pre></div></div>

<p>H√° ainda outros escopos diferentes para vari√°veis em Ruby, mas vamos deixar pra comentar sobre eles mais pra frente neste guia.</p>

<h2 id="tipos-de-par√¢metros">Tipos de par√¢metros</h2>

<p>Em Ruby h√° diversas op√ß√µes de par√¢metros para utilizar na defini√ß√£o de m√©todos. Al√©m do par√¢metro obrigat√≥rio, guia vamos discutir duas outras formas: os par√¢metros <em>default</em> e os par√¢metros opcionais.</p>

<h3 id="par√¢metros-default">Par√¢metros <em>default</em></h3>

<p>No exemplo que trabalhamos acima, o nosso m√©todo <code class="highlighter-rouge">converter_para_dolar</code> recebia um √∫nico par√¢metro, o <code class="highlighter-rouge">valor_para_converter</code>. Toda vez que chamamos o m√©todo <code class="highlighter-rouge">converter_para_dolar</code>, precisamos obrigatoriamente passar um valor para o par√¢metro; do contr√°rio, recebemos um erro com a seguinte mensagem <code class="highlighter-rouge">ArgumentError (wrong number of arguments (given 0, expected 1))</code>. Isso acontece pois o par√¢metro √© <em>obrigat√≥rio</em>.</p>

<p>No entanto, em Ruby √© poss√≠vel fornecer um valor padr√£o para um par√¢metro (do Ingl√™s, <em>default parameters</em>), ou seja, caso um valor n√£o seja passado para o m√©todo, a vari√°vel definida no par√¢metro receber√° um valor previamente definido. Podemos alterar nosso <code class="highlighter-rouge">converter_para_dolar</code> para receber um valor padr√£o da seguinte forma:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span><span class="p">,</span> <span class="n">cotacao_dolar</span><span class="o">=</span><span class="mf">5.61</span>
 <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao_dolar</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span>
</code></pre></div></div>

<p>Nesse exemplo, a vari√°vel <code class="highlighter-rouge">cotacao_dolar</code> passou a ser um par√¢metro <em>default</em> do m√©todo <code class="highlighter-rouge">converter_para_dolar</code>, e o usu√°rio deste m√©todo ganhou a opcionalidade de passar esse par√¢metro ou n√£o (veja que na chamada do m√©todo passamos somente o valor a ser convertido).</p>

<p>Como o valor padr√£o s√≥ ser√° atribu√≠do caso o usu√°rio n√£o passe o valor desejado, nada impede que informe outro valor como par√¢metro. Neste caso, o valor que o usu√°rio informa ser√° utilizado, enquanto que o valor <em>default</em> n√£o ser√° utilizado. Experimente fazendo a seguinte chamada de m√©todo <code class="highlighter-rouge">converter_para_dolar 100, 5.8</code>.</p>

<p>Por fim, perceba tamb√©m que no m√©todo <code class="highlighter-rouge">converter_para_dolar</code> h√° ainda um par√¢metro obrigat√≥rio. Se executarmos novamente o m√©todo <code class="highlighter-rouge">converter_para_dolar</code> sem passar nenhum par√¢metro, temos a seguinte mensagem de erro: <code class="highlighter-rouge">ArgumentError (wrong number of arguments (given 0, expected 1..2))</code>. Diferente da mensagem de erro que tivemos anteriormente, que sab√≠amos exatamente quantos valores eram esperados, agora o Ruby nos avisa que √© esperado um <code class="highlighter-rouge">Range</code> que varia de 1 at√© 2.</p>

<h3 id="par√¢metros-opcionais">Par√¢metros opcionais</h3>

<p>Um outro recurso interessante em m√©todos s√£o os par√¢metros opcionais. Diferente dos par√¢metros <em>default</em>, em que um valor vai ser passado para uma vari√°vel, independentemente se o usu√°rio fornecer esse valor ou n√£o, nos par√¢metros opcionais, podemos contar ou n√£o com os par√¢metros para execu√ß√£o do nosso m√©todo. Ou seja, o m√©todo n√£o sabe quantos par√¢metros ser√£o providos a cada chamada de m√©todo. Declaramos que um par√¢metro √© opcional atrav√©s do s√≠mbolo <code class="highlighter-rouge">*</code> utilizado <em>antes</em> do nome do par√¢metro.</p>

<p>Para entender um pouco mais, consider o caso em que n√≥s temos v√°rias cota√ß√µes de d√≥lar, mas nem todas est√£o dispon√≠veis ao mesmo instante. Logo, podemos fazer a nossa convers√£o para d√≥lar somente com as cota√ß√µes que est√£o dispon√≠veis em um determinado momento. Vejamos o exemplo abaixo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span><span class="p">,</span> <span class="o">*</span><span class="n">cotacoes_dolar</span>
  <span class="k">for</span> <span class="n">cotacao</span> <span class="k">in</span> <span class="n">cotacoes_dolar</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="n">valor_para_converter</span> <span class="o">/</span> <span class="n">cotacao</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="n">converter_para_dolar</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">5.61</span><span class="p">,</span> <span class="mf">5.6</span><span class="p">,</span> <span class="mf">5.65</span><span class="p">,</span> <span class="mf">5.58</span>
</code></pre></div></div>

<p>Algumas observa√ß√µes sobre o uso do par√¢metro opcional:</p>

<ul>
  <li>
    <p>Usamos o <code class="highlighter-rouge">*</code> somente na declara√ß√£o da vari√°vel, e n√£o no seu uso (diferente do <code class="highlighter-rouge">$</code> que usamos para declarar vari√°veis globais, que precisamos utilizar tanto na declara√ß√£o quanto no uso).</p>
  </li>
  <li>
    <p>O nosso m√©todo <code class="highlighter-rouge">converter_para_dolar</code> recebeu cinco par√¢metros, mas poderia ter recebido tr√™s, oito, dez, ‚Ä¶,  ou  somente um. Ou seja, poder√≠amos passar somente o par√¢metro obrigat√≥rio e n√£o passar nenhum par√¢metro opcional. Caso nenhum par√¢metro opcional fosse fornecido, o <code class="highlighter-rouge">for</code> n√£o seria executado. Faz sentido usar par√¢metros opcionais nesse caso, ent√£o?</p>
  </li>
  <li>
    <p>Quando passamos um ou mais valores para um par√¢metro opcional, esses valores s√£o armazenados em um <code class="highlighter-rouge">Array</code>. Logo, a chamada de m√©todo <code class="highlighter-rouge">converter_para_dolar 100, 5.61, 5.6, 5.65, 5.58</code> √© equivalente a <code class="highlighter-rouge">converter_para_dolar 100, [5.61, 5.6, 5.65, 5.58]</code>.</p>
  </li>
</ul>

<h3 id="podemos-combinar-par√¢metros-obrigat√≥rios-default-e-opcionais">Podemos combinar par√¢metros obrigat√≥rios, default e opcionais?</h3>

<p>Sim! Podemos usar todos os tr√™s tipos de par√¢metros na defini√ß√£o da assinatura de um √∫nico m√©todo. Mas note que, assim como os operadores tem diferentes graus de preced√™ncia sobre outros operadores (por exemplo, o operador <code class="highlighter-rouge">*</code> √© avaliado antes do operador <code class="highlighter-rouge">+</code>).</p>

<p>Caso seja de interesse utilizar os tr√™s tipos de par√¢metros no mesmo m√©todo, uma boa pr√°tica √© utilizar primeiro os par√¢metros obrigat√≥rio, depois os <em>default</em> e por fim os opcionais. Algo como:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span><span class="p">,</span> <span class="n">cotacoes_dolar</span><span class="o">=</span><span class="mf">5.61</span><span class="p">,</span> <span class="o">*</span><span class="n">outras_cotacoes</span>
  <span class="nb">puts</span> <span class="s2">"Eu quero converter o valor </span><span class="si">#{</span><span class="n">valor_para_converter</span><span class="si">}</span><span class="s2"> usando a cota√ß√£o </span><span class="si">#{</span><span class="n">cotacoes_dolar</span><span class="si">}</span><span class="s2"> e, se poss√≠vel, usando tamb√©m as cota√ß√µes </span><span class="si">#{</span><span class="n">outras_cotacoes</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">converter_para_dolar</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">5.80</span><span class="p">,</span> <span class="mf">5.66</span><span class="p">,</span> <span class="mf">5.26</span><span class="p">,</span> <span class="mf">5.63</span><span class="p">,</span> <span class="mf">5.72</span>
<span class="n">converter_para_dolar</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">5.80</span><span class="p">,</span> <span class="mf">5.66</span>
<span class="n">converter_para_dolar</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">5.80</span>
</code></pre></div></div>

<h2 id="tipos-de-retorno">Tipos de retorno</h2>

<p>Como j√° discutimos no come√ßo deste cap√≠tulo, todo m√©todo em Ruby retorna algum valor, mesmo que n√£o exista um <code class="highlighter-rouge">return</code> expl√≠cito no c√≥digo. Neste caso, o m√©todo retorna a √∫ltima linha. No entanto, caso mais de uma express√£o seja fornecida, um <code class="highlighter-rouge">Array</code> agrupando os valores das express√µes √© retornado. Poder√≠amos observar esse comportamento se coloc√°ssemos um <code class="highlighter-rouge">return</code> com mais de um valor, separado por v√≠rgulas:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span><span class="p">,</span> <span class="n">cotacoes_dolar</span><span class="o">=</span><span class="mf">5.61</span><span class="p">,</span> <span class="o">*</span><span class="n">outras_cotacoes</span>
  <span class="c1"># ...</span>

  <span class="k">return</span> <span class="n">valor_para_converter</span><span class="p">,</span> <span class="n">valor_convertido</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Por fim, e embora n√£o recomendado, podemos tamb√©m retornar <code class="highlighter-rouge">nil</code>, caso a √∫ltimas instru√ß√£o do m√©todo senha somente um <code class="highlighter-rouge">return</code> sem valor. Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">converter_para_dolar</span> <span class="n">valor_para_converter</span><span class="p">,</span> <span class="n">cotacoes_dolar</span><span class="o">=</span><span class="mf">5.61</span><span class="p">,</span> <span class="o">*</span><span class="n">outras_cotacoes</span>
  <span class="c1"># ...</span>

  <span class="k">return</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="m√©todos-ou-blocos">M√©todos ou blocos?</h2>

<p>Como j√° vimos em outros cap√≠tulos, bloco s√£o uma forma de agrupar express√µes. Embora blocos sejam comumente delimitados entre um <code class="highlighter-rouge">do..end</code>, blocos de uma √∫nica linha podem ser delimitados por chaves <code class="highlighter-rouge">{}</code>. Blocos, assim como m√©todos, podem conter seus pr√≥prios argumentos. Diferente de m√©todos, blocos n√£o tem nome (e tamb√©m n√£o s√£o associados a nenhum objeto). Os exerc√≠cios que fizemos usando <code class="highlighter-rouge">loop</code> e <code class="highlighter-rouge">1.times</code> no cap√≠tulo anterior foram usando blocos.</p>

<p>Mas qual a rela√ß√£o de um m√©todo e um bloco? Considere o trecho de c√≥digo abaixo.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bloco_metodo</span>
  <span class="nb">puts</span> <span class="s2">"Estou dentro de um m√©todo"</span>
<span class="k">end</span>

<span class="n">bloco_metodo</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"Um bloco foi chamado"</span><span class="p">}</span>
</code></pre></div></div>

<p>Nas tr√™s primeiras linhas do exemplo acima n√≥s declaramos o m√©todo <code class="highlighter-rouge">bloco_metodo</code> enquanto que na √∫ltima linha n√≥s chamamos esse m√©todo passando um bloco para ele.</p>

<p>Sem executar esse programa, voc√™ saberia dizer qual √© a sa√≠da?</p>

<p>A sa√≠da √© a <code class="highlighter-rouge">String</code> contendo <code class="highlighter-rouge">Estou dentro de um m√©todo</code>. Isso acontece pois o bloco n√£o foi invocado. Para invocar um bloco, podemos fazer uso da palavra reservada <code class="highlighter-rouge">yield</code>.  Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bloco_metodo</span>
  <span class="nb">puts</span> <span class="s2">"Estou dentro de um m√©todo"</span>
  <span class="k">yield</span>
  <span class="nb">puts</span> <span class="s2">"Estou de volta para o m√©todo"</span>
<span class="k">end</span>

<span class="n">bloco_metodo</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"Um bloco foi chamado"</span><span class="p">}</span>
</code></pre></div></div>

<p>A palavra reservada <code class="highlighter-rouge">yield</code> vai procurar e invocar o bloco no m√©todo que foi invocado. Ou seja, o <code class="highlighter-rouge">yield</code> vai at√© a chamada do m√©todo e executa o bloco e depois retorna ao m√©todo para terminar sua execu√ß√£o. Perceba que n√£o estamos passando o bloco por par√¢metro do m√©todo e, sim, estamos chamando o bloco de dentro do m√©todo. N√£o passamos o bloco como par√¢metro pois, como dissemos no come√ßo desta se√ß√£o, um bloco n√£o √© um objeto.</p>

<p>Mas o que aconteceria se nenhum bloco fosse passado? Se fizermos somente a chamada do m√©todo <code class="highlighter-rouge">bloco_metodo</code>, sem passar o bloco, recebemos um erro do tipo <code class="highlighter-rouge">LocalJumpError (no block given (yield))</code>. Isso acontece pois o <code class="highlighter-rouge">yield</code></p>

<p>√â poss√≠vel tamb√©m passar par√¢metros para dentro de um bloco. No cap√≠tulo anterior usamos o seguinte trecho de c√≥digo: <code class="highlighter-rouge">5.times {|i| puts "Eu sei iterar at√© #{i}"}</code>, onde <code class="highlighter-rouge">i</code> √© uma vari√°vel passada por par√¢metro para dentro de um bloco, atrav√©s do m√©todo <code class="highlighter-rouge">times</code>. Como isso √© poss√≠vel?</p>

<p>Podemos passar par√¢metros para o bloco tamb√©m usando o <code class="highlighter-rouge">yield</code>. Por exemplo:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bloco_metodo</span>
  <span class="nb">puts</span> <span class="s2">"Estou dentro de um m√©todo"</span>
  <span class="k">yield</span> <span class="mi">1</span>
  <span class="nb">puts</span> <span class="s2">"Estou de volta para o m√©todo"</span>
  <span class="k">yield</span>
<span class="k">end</span>

<span class="n">bloco_metodo</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="s2">"Imprimindo o par√¢metro </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span><span class="p">}</span>
</code></pre></div></div>

<p>No exemplo acima, o <code class="highlighter-rouge">yield</code> √© chamado duas vezes, cada uma passando uma par√¢metro diferente.</p>

<!--
## Escopo de vari√°veis

O escopo √© o que define onde uma vari√°vel pode ser acessada. O escopo pode ser pequeno, a n√≠vel local, ou pode ser grande, a n√≠vel global.

https://stackoverflow.com/questions/11495098/difference-between-various-variables-scopes-in-ruby

https://www.techotopia.com/index.php/Ruby_Variable_Scope

https://www.rubyguides.com/2019/03/ruby-scope-binding/

-->

<h2 id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de fixa√ß√£o</h2>

<!--
```ruby
x = 0

def foo
    x = 10
    return x
end

bar = foo

def baz
    x = 20
    bar()
end

puts baz
```
-->

<ul>
  <li>
    <p>Escreva a seu pr√≥prio m√©todo que imprima na tela do usu√°rio, similar ao <code class="highlighter-rouge">puts</code>.</p>
  </li>
  <li>
    <p>Al√©m de m√©todos e blocos, em Ruby h√° tamb√©m uma estrutura chamada <code class="highlighter-rouge">Proc</code>. Estude e entenda as diferen√ßas entre estas tr√™s estruturas.</p>
  </li>
  <li>
    <p>Dissemos ao fim do cap√≠tulo que blocos n√£o s√£o objetos, logo n√£o podem ser passados por par√¢metros para um m√©todo. No entanto, o c√≥digo abaixo √© funcional. Explique o por que.</p>
  </li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bloco_como_parametro</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bloco</span><span class="p">)</span>
  <span class="n">bloco</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>

<span class="n">bloco_como_parametro</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"N√£o √© que funciona?!"</span> <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Crie um programa que execute o comando <code class="highlighter-rouge">times (5) { .. }</code> com comportamento similar ao <code class="highlighter-rouge">5.times { .. }</code>.</p>
  </li>
  <li>
    <p>M√©todos tem par√¢metros opcionais que s√£o convertidos para um <code class="highlighter-rouge">Array</code>. Esses par√¢metros s√£o identificados pelo s√≠mbolo <code class="highlighter-rouge">*</code> que antecede o nome do par√¢metro. No entanto, h√° tamb√©m outro tipo de par√¢metro opcional que √© definido com dois <code class="highlighter-rouge">**</code>.  Que tipo de par√¢metro √© esse?</p>
  </li>
  <li>
    <p>Um outro tipo de par√¢metro √© com um operador <em>ampersand</em> (<code class="highlighter-rouge">&amp;</code>). Em que caso um par√¢metro com esse operador deve ser utilizado?</p>
  </li>
  <li>
    <p>Pesquise se seria poss√≠vel ter outra ordem de preced√™ncia (diferente de obrigat√≥rios, <em>default</em> e opcionais) para os tipos de par√¢metros de um m√©todo.</p>
  </li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Como j√° discutimos em outros cap√≠tulos, os par√™nteses <code class="highlighter-rouge">()</code> s√£o opcionais tanto na defini√ß√£o quanto no uso de m√©todos em Ruby.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET