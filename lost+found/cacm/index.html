<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" prefix="schema: http://schema.org/ prism: http://prismstandard.org/namespaces/basic/2.0/"><head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  

  <link rel="stylesheet" href="css/bootstrap.min.css" />
  <link rel="stylesheet" href="css/rash.css" />
  <!-- Local MathJax -->
  <!-- <script src="js/MathJax/MathJax.js"></script> -->

  <!-- online MathJax -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG"></script>

  <!-- JQuery -->
  <script src="js/jquery.min.js"></script>
  <script src="js/jquery.xpath.min.js">
  </script>
  <!-- Bootstrap.js -->
  <script src="js/bootstrap.min.js"></script>

  <!-- Rash.js -->
  <script src="js/rash_annotation.js"></script>
  <script src="js/rash.js"></script>

  <title>Energy Efficiency: A New Concern for Application Software Developers</title>
  
  
  
  
  

<meta about="mailto:gpinto@ufpa.br" typeof="schema:Person" property="schema:name" name="dc.creator" content="Gustavo Pinto" /><meta about="mailto:gpinto@ufpa.br" property="schema:email" content="gpinto@ufpa.br" /><link about="mailto:gpinto@ufpa.br" property="schema:affiliation" href="#affiliation_1" /><meta about="mailto:castor@cin.ufpe.br" typeof="schema:Person" property="schema:name" name="dc.creator" content="Fernando Castor" /><meta about="mailto:castor@cin.ufpe.br" property="schema:email" content="castor@cin.ufpe.br" /><link about="mailto:castor@cin.ufpe.br" property="schema:affiliation" href="#affiliation_2" /><meta about="#affiliation_1" typeof="schema:Organization" property="schema:name" content="Federal University of Pará" /><meta about="#affiliation_2" typeof="schema:Organization" property="schema:name" content="Federal University of Pernambuco" /><meta property="prism:keyword" content="Software Energy Consumption" /><meta property="prism:keyword" content="Lack of Knowledge" /><meta property="prism:keyword" content="Lack of Tools" /><meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0" /></head>

<body>

<section role="doc-abstract" id="doc-abstract">
<h1>Abstract</h1>
<p>Energy efficiency is a problem that must be addressed at all levels of the software stack. However, developing energy-efficient software is not an easy task. In this paper we argue that this is mostly due to two main problems: the lack of knowledge and the lack of tools. These problems prevent software developers from identifying, refactoring, fixing, and removing energy consumption hotspots. We review how current research in the area of software engineering is tackling these two problems. Furthermore, based on an investigation on the problems faced by energy-aware developers, we discuss avenues for future research in the area.</p>
</section>
<section id="section1">
<h1>Introduction</h1>
<p>The prevalence and ubiquity of mobile computing platforms such as smartphones, tablets, smartwatches, and smartglasses changed the way people use and interact with software. In particular, these platforms share a common yet challenging requirement: they are battery-driven. As users interact with them, they tend to be less available, since even simple, well-optimized operations (<em>e.g.,</em> texting a friend) consume energy. At the same time, wasteful, poorly-optimized software can deplete a device's battery much faster than necessary. Heavy resource usage has been shown to be one of the reasons leading to poor app reviews in online app stores <a href="#biblioentry_46"> </a> .</p>
<p>This concern, however, pertains not only to mobile platforms. Big players of the software industry are also reaching the same conclusion, as stated in one of the very few energy efficient software development guides: "<em>Even small inefficiencies in apps add up across the system, significantly affecting battery life, performance, responsiveness, and temperature</em>"<a href="#endnote_1"> </a>. Corporations that maintain data centers struggle with soaring energy costs. These costs can be attributed in part to overprovisioning with severs constantly operating under their maximum capacity (<em>e.g.</em>, America's data centers are wasting huge amount of energy <a href="#biblioentry_34"> </a>), and to the developers of the apps running on these data centers generally not taking energy into consideration <a href="#biblioentry_24"> </a>.</p>
<p>Unfortunately, during the last decades, little attention has been placed on creating techniques, tools, and processes to empower software developers to better understand and use energy resources. As a consequence, software developers still lack textbooks, guidelines, courses, and tools to refer to when dealing with energy consumption issues <a href="#biblioentry_24"> </a> <a href="#biblioentry_22"> </a>. Moreover, most of the research that connects computing and energy efficiency has concentrated on the lower levels of the hardware and software stack.</p>
<p>However, recent studies show that these lower level solutions do not capture the whole picture <a href="#biblioentry_39"> </a> <a href="#biblioentry_4"> </a> <a href="#biblioentry_49"> </a>, when it comes to energy consumption. Although software systems do not consume energy themselves, they affect hardware utilization, leading to indirect energy consumption.</p>
<section id="section2">
<h2>How is software related to energy consumption?</h2>
<p>Energy consumption <span id="formula_1" contenteditable="false" data-math-original-input="E"><svg 1998="" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="1.776ex" height="2.083ex" viewBox="0 -775.8 764.5 896.9" role="math" focusable="false" aria-hidden="true" style="vertical-align: -0.281ex;" data-math-original-input="E" data-mathml="&lt;math xmlns=" http:="" www="" w3="" org="" math="" mathml=""><mstyle displaystyle="true"><mi>E</mi></mstyle>"&gt;<defs><path stroke-width="1" id="E126-MJMATHI-45" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink="http://www.w3.org/1999/xlink" href="#E126-MJMATHI-45" x="0" y="0"/></g></svg></span> is an accumulation of power dissipation <span id="formula_1" contenteditable="false" data-math-original-input="P"><svg 1998="" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.083ex" viewBox="0 -775.8 751.5 896.9" role="math" focusable="false" aria-hidden="true" style="vertical-align: -0.281ex;" data-math-original-input="P" data-mathml="&lt;math xmlns=" http:="" www="" w3="" org="" math="" mathml=""><mstyle displaystyle="true"><mi>P</mi></mstyle>"&gt;<defs><path stroke-width="1" id="E126-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink="http://www.w3.org/1999/xlink" href="#E126-MJMATHI-50" x="0" y="0"/></g></svg></span> over time <span id="formula_1" contenteditable="false" data-math-original-input="t"><svg 1998="" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.945ex" viewBox="0 -716.3 361.5 837.3" role="math" focusable="false" aria-hidden="true" style="vertical-align: -0.281ex;" data-math-original-input="t" data-mathml="&lt;math xmlns=" http:="" www="" w3="" org="" math="" mathml=""><mstyle displaystyle="true"><mi>t</mi></mstyle>"&gt;<defs><path stroke-width="1" id="E128-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink="http://www.w3.org/1999/xlink" href="#E128-MJMATHI-74" x="0" y="0"/></g></svg></span>, that is, <span id="formula_1" contenteditable="false" data-math-original-input="E = P \times t"><svg 1998="" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="10.764ex" height="2.083ex" viewBox="0 -775.8 4634.5 896.9" role="math" focusable="false" aria-hidden="true" style="vertical-align: -0.281ex;" data-math-original-input="E = P \times t" data-mathml="&lt;math xmlns=" http:="" www="" w3="" org="" math="" mathml=""><mstyle displaystyle="true"><mi>E</mi><mo>=</mo><mi>P</mi><mo>×</mo><mi>t</mi></mstyle>"&gt;<defs><path stroke-width="1" id="E132-MJMATHI-45" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/><path stroke-width="1" id="E132-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path stroke-width="1" id="E132-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/><path stroke-width="1" id="E132-MJMAIN-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/><path stroke-width="1" id="E132-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink="http://www.w3.org/1999/xlink" href="#E132-MJMATHI-45" x="0" y="0"/><use xlink="http://www.w3.org/1999/xlink" href="#E132-MJMAIN-3D" x="1097" y="0"/><use xlink="http://www.w3.org/1999/xlink" href="#E132-MJMATHI-50" x="2209" y="0"/><use xlink="http://www.w3.org/1999/xlink" href="#E132-MJMAIN-D7" x="3227" y="0"/><use xlink="http://www.w3.org/1999/xlink" href="#E132-MJMATHI-74" x="4273" y="0"/></g></svg></span>. Power <span id="formula_1" contenteditable="false" data-math-original-input="P"><svg 1998="" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.083ex" viewBox="0 -775.8 751.5 896.9" role="math" focusable="false" aria-hidden="true" style="vertical-align: -0.281ex;" data-math-original-input="P" data-mathml="&lt;math xmlns=" http:="" www="" w3="" org="" math="" mathml=""><mstyle displaystyle="true"><mi>P</mi></mstyle>"&gt;<defs><path stroke-width="1" id="E126-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink="http://www.w3.org/1999/xlink" href="#E126-MJMATHI-50" x="0" y="0"/></g></svg></span> is measured in watts, whereas energy <span id="formula_1" contenteditable="false" data-math-original-input="E"><svg 1998="" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="1.776ex" height="2.083ex" viewBox="0 -775.8 764.5 896.9" role="math" focusable="false" aria-hidden="true" style="vertical-align: -0.281ex;" data-math-original-input="E" data-mathml="&lt;math xmlns=" http:="" www="" w3="" org="" math="" mathml=""><mstyle displaystyle="true"><mi>E</mi></mstyle>"&gt;<defs><path stroke-width="1" id="E126-MJMATHI-45" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink="http://www.w3.org/1999/xlink" href="#E126-MJMATHI-45" x="0" y="0"/></g></svg></span> is measured in joules. As an example, if one operation takes 10 seconds to complete and dissipates 5 watts, it consumes 50 joules of energy. In particular, when taking about software energy consumption, one should pay attention to:</p>
<ul>
<li>
<p>a given software system under execution,</p>
</li>
<li>
<p>on a given hardware platform,</p>
</li>
<li>
<p>on a given context,</p>
</li>
<li>
<p>during a given time.</p>
</li>
</ul>
<p>To understand the importance of a <em>hardware platform</em>, consider an application that uses the network. Any commodity smartphone nowadays supports, at least, WiFi, 3G, and 4G. A recent study observed that 3G can consume about 1.7x more energy than WiFi, whereas 4G can consume about 1.3x more energy than 3G, while performing the same task, on the same hardware platform<a href="#biblioentry_1"> </a>.</p>
<p><em>Context</em> also plays a key role, since the way software is built and used has a critical influence on energy consumption. For instance, software can stress energy consumption on CPUs, when performing CPU-intensive computations <a href="#biblioentry_3"> </a>, on DRAMs, when performing random accesses to data structures <a href="#biblioentry_2"> </a>, on networks, when running several <a href="#biblioentry_4"> </a><a href="#biblioentry_5"> </a>, and on displays, when using lighter backgrounds <a href="#biblioentry_5"> </a> <a href="#biblioentry_21"> </a> or playing videos.</p>
<p>Finally, <em>time</em> plays a key role in this equation, A common misconception among developers is that reducing execution time also reduces energy consumption <a href="#biblioentry_22"> </a> <a href="#biblioentry_24"> </a>, the <span id="formula_1" contenteditable="false" data-math-original-input="t"><svg 1998="" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.945ex" viewBox="0 -716.3 361.5 837.3" role="math" focusable="false" aria-hidden="true" style="vertical-align: -0.281ex;" data-math-original-input="t" data-mathml="&lt;math xmlns=" http:="" www="" w3="" org="" math="" mathml=""><mstyle displaystyle="true"><mi>t</mi></mstyle>"&gt;<defs><path stroke-width="1" id="E128-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink="http://www.w3.org/1999/xlink" href="#E128-MJMATHI-74" x="0" y="0"/></g></svg></span> of the equation. However, chances are that this reduction in execution time might increase the number of CPU cycles (<em>e.g.</em>, using multi-core CPUs) and, therefore, the number of context switches. This, in turn, might increase the <span id="formula_1" contenteditable="false" data-math-original-input="P"><svg 1998="" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.083ex" viewBox="0 -775.8 751.5 896.9" role="math" focusable="false" aria-hidden="true" style="vertical-align: -0.281ex;" data-math-original-input="P" data-mathml="&lt;math xmlns=" http:="" www="" w3="" org="" math="" mathml=""><mstyle displaystyle="true"><mi>P</mi></mstyle>"&gt;<defs><path stroke-width="1" id="E126-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink="http://www.w3.org/1999/xlink" href="#E126-MJMATHI-50" x="0" y="0"/></g></svg></span> of the equation, impacting the resulting energy consumption.</p>
</section>
<section id="section3">
<h2>Software engineering meets energy consumption</h2>
<p>While the strategy of leaving the energy consumption optimization problem to the lower-level layers has been successful, recent studies show that even better energy savings can be achieved by empowering and encouraging software developers to participate in the process <a href="#biblioentry_1"> </a><a href="#biblioentry_2"> </a><a href="#biblioentry_4"> </a><a href="#biblioentry_33"> </a>. However, the application level, which is the focus of most mainstream software being developed these days, has been the target of few studies.</p>
<p>This lack of studies was observed in a recent paper<a href="#biblioentry_6"> </a>, where the authors surveyed the papers published during a period of 10 years in top software engineering venues, and found only 20 research papers that have "power" or "energy" on their titles or abstracts. More interestingly, however, the authors observed that none of them were published before 2012. In 2012, 3 papers were published, whereas 6 papers were published in 2013 and 11 papers in 2014. That shows the emerging character of the field.</p>
<p>The need for studies that focus on the higher levels of the software stack is important from at least two important perspectives:</p>
<ul>
<li>
<p><strong>Software engineer's perspective.</strong> Battery usage is a key factor for adopting and evaluating mobile applications. Users of an energy-inefficient app might review it badly, encouraging other users not to use it. This can negatively impact the app's revenue.</p>
</li>
</ul>
<ul>
<li>
<p><strong>End user's perspective.</strong> The last mile in energy efficiency comes from the choices of end-users. To make better choices, and further minimize energy consumption, end users should be aware of the different energy characteristics of software applications that serve the same purpose.</p>
</li>
</ul>
<p><em><strong>This paper.</strong></em> This paper is a review of the most prominent software engineering approaches for writing, maintaining, and evolving energy-efficient software applications. We organize the contributions according to the Guide to the Software Engineering Body of Knowledge (SWEBOK) <a href="#biblioentry_8"> </a>, a common practice in software engineering studies (<em>e.g.</em>, <a href="#biblioentry_28"> </a>). When conducing such review, we found that the literature does not cover well certain areas of the SWEBOK. For these cases, we share our visions of possible research avenues that energy-aware researchers can follow to reduce this gap.</p>
<p>The rest of the paper is organized as follows: <a href="#section4"> </a> unveils the perceptions of mobile developers when dealing with energy consumption issues, scratching their problems and possible solutions. <a href="#section5"> </a> acknowledges that most of the energy-related problems, in fact, can be reduced to two main problems: the lack of knowledge and the lack of tools. <a href="#section6"> </a> surveys recent literature to understand how software engineering researchers are tackling these two problems. <a href="#section11"> </a> concludes this work.</p>
</section>
</section>
<section id="section4">
<h1>A Formative Study</h1>
<p>Energy consumption issues are now knocking on the door of application software developers. To shed light on this matter, similarly to Pang <em>et al. </em><a href="#biblioentry_33"> </a>, we conducted a survey with software developers to understand their perceptions about software energy consumption issues. Differently from this previous paper, which surveyed a wide range of software developers, our target population is more focused and consists of 62 software developers who have performed at least one commit to a mobile open-source application.</p>
<p>Among the respondents, 68.75% have more than 8 years of software development experience, 57.81% have more than 2 years of mobile development experience, and 77.41% have more than 2 years of open-source development experience. The majority of them (57.8%) are source code contributors or project owners (35.9%). More interestingly, 70.31% of the respondents agree that energy consumption could be an issue in their mobile applications. Also, 37 respondents have already faced energy-related problems, as a respondent said: "<em>We have a limited energy envelope for the whole system and we must make sure even our power hungry components don't cause the system to go beyond this limit</em>". Also, some respondents are aware that energy inefficiencies can impact on app popularity and, therefore, revenue: "<em>Users will leave bad reviews if you drain the battery"</em>.</p>
<p>When asked if they found the root cause for the energy-related problems, 50% of the respondents did not answer. For those who answered, background activities, GPS, and unnecessary resource usage are among the recurring answers. Interestingly, these problems were also observed in other studies <a href="#biblioentry_22"> </a><a href="#biblioentry_24"> </a>. However, 31.81% of the respondents did not observe any significant improvement in energy consumption after applying their solutions. For those who observed an improvement, only 5 of them made use of specialized tools. The majority of them have the <em>perception</em> of an improvement, <em>e.g.</em>: "<em>The battery is lasting longer</em>", "<em>Less heat from device</em>", or "<em>I really do not measure before and after. It's just a perception</em>". When we asked where they find reliable information about what solutions can be used to save energy, 7 of them refer to the official documentation, 5 of them use StackOverflow, and 5 use other channels (blogs, youtube, open-source repositories). Unfortunately, the solutions described in such sources of documentation often are not supported by empirical evidence <a href="#biblioentry_22"> </a> <a href="#biblioentry_7"> </a>. To make the matter worse, two respondents rely on "Trial and error", which is far from being accurate.</p>
<p>Moreover, 67% of the respondents said that energy-related features are "important" or "very important" to have in well-known IDEs. Only 8 of the overall respondents have actually used software energy consumption tools. Respondents said that the most important energy-related features to have in well-known IDEs are profiling tools (16 answers), varying from CPU, network, method, wakelocks, thread, and live profile. Indeed, one respondent synthesize that well-known IDEs, such as Android Studio, lack these features: "<em>Android Studio needs a good energy profiler to check the Android power consumption from all power consumers (radios, CPU, memory, storage, everything)</em>." These results not only corroborate with the findings of Pang <em>et al.</em> <a href="#biblioentry_33"> </a>, but also reinforce that application-level energy management is in high demand among application software developers, although better support is urgently needed.</p>
<p>We also asked five leading researchers in the area of Software Energy Consumption what are, on their opinions, the most significant contributions and biggest open challenges in this area.  All the researchers agreed that tool support is still lacking when it comes to energy measurement, reengineering, refactoring, and other related activities. Even though there is a recent interest from IDE builders to provide an energy consumption perspective of the software systems under development<a href="#endnote_2"> </a>, this finding suggests that there is much to do still.</p>
</section>
<section id="section5">
<h1>Energy-Related Problems</h1>
<p>As observed in our formative study, software developers currently have to rely on Q&amp;A websites, blog posts, or youtube videos when trying to optimize energy consumption, which are anecdotal, not supported by empirical evidence, or even incorrect <a href="#biblioentry_48"> </a> <a href="#biblioentry_24"> </a>. The consequence of the lack of appropriate textbooks, guidelines, and cookbooks for green software development is the <em>Lack of knowledge</em> on how to write, maintain, and evolve energy-efficient software applications. Furthermore, our respondents also mentioned that they believe that energy-related features are very important to have in well-known IDEs. In particular, energy profiling techniques can be very helpful. This lack of energy-related features incurs in the <em>Lack of tools</em> to find, refactor, and fix energy-inefficient code.</p>
<p>The lack of knowledge and the lack of tools to write energy-efficient software is also discussed in the literature. For instance, Pinto <em>et al</em>. <a href="#biblioentry_22"> </a> noticed that a common <em>misconception</em> is to confuse concepts such as "power" and "energy". Manotas <em>et al.</em> <a href="#biblioentry_24"> </a> observed that developers believe in <em>panaceas</em>, that is, solutions that are presented as universal but, in fact, only work in specific contexts. For instance, while one developer suggested "<em>offloading computation to the cloud</em>" as a way to improve energy consumption, another developer mentioned "decreased radio use increases battery life". As a result, developers should consider the underlying thresholds to take proper advantage of each solution. These are examples of lack of knowledge.<br />To further complicate matters, optimizing performance does not always help to save energy <a href="#biblioentry_49"> </a> <a href="#biblioentry_23"> </a> ,<a href="#biblioentry_19"> </a> <a href="#biblioentry_3"> </a>. Thus, the extensive performance textbooks and guidelines are not always useful.</p>
<p>The aforementioned lack of knowledge is intrinsically connected to the lack of tools. Moura <em>et al.</em> <a href="#biblioentry_7"> </a> observed that energy-aware developers often employ low-level solutions that sometimes result in hard-to-detect <em>correctness</em> problems. The following commit message provides an example of a correctness problem: "<em>Disable Auto Power Saving when resetting the modem. This can cause several bugs with serial communication</em>"<a href="#endnote_3"> </a>. High-level energy saving tools might be useful in mitigating this problem. In addition, Pang <em>et al.</em> <a href="#biblioentry_33"> </a> found that 88% of the respondents of their survey do not know what tool they can use to measure the energy consumption of their software. These are examples of lack of tools. Although software energy consumption tools do exist, they have yet-to-be-addressed limitations:</p>
<ul>
<li>
<p>They require an in-depth knowledge of low-level implementation details and programmers under time pressure have little chance to learn how to use them;</p>
</li>
<li>
<p>They do not provide direct guidance on energy optimization, <em>i.e.</em>, bridging the gap between understanding where energy is consumed and understanding how the code can be modified in order to reduce energy consumption.</p>
</li>
</ul>
<p>The next section discusses how current software engineering research is addressing these two key problems.</p>
</section>
<section id="section6">
<h1>Energy-Related Solutions</h1>
<p>Since there is no single solution for conserving energy, we organize the contributions in terms of the topics of the SWEBOK <a href="#biblioentry_8"> </a>, a common practice in software engineering studies (<em>e.g.</em>, <a href="#biblioentry_28"> </a>). Although energy consumption can be related to any software engineering topic, we chose to focus only on topics directly related to software coding, since (1) it is one of the main activities of software developers, and (2) it is the target of most of the recent research contributions. Therefore, we do not cover the following topics: software configuration management, software engineering management, software engineering process, and software requirements.</p>
<section id="section7">
<h2>Software Tools &amp; Methods</h2>
<p>We organize our discussion of software engineering tools and methods in terms of enhancement methods, measurement tools, and static analysis tools.</p>
<p><em><strong>Enhancement methods.</strong></em> These methods refer to energy saving techniques that developers can use, even though they have no prior knowledge of the application domain. For instance, software developers often leverage modern CPUs to dynamically change their operating frequencies, thus reducing power dissipation <a href="#biblioentry_7"> </a>. However, when applying this technique, software developers should use low-level system interfaces, which are error-prone and platform dependent. Notwithstanding, blindly downscaling CPU frequency might increase energy consumption while reducing performance <a href="#biblioentry_2"> </a><a href="#biblioentry_15"> </a>. This is an important example of the <em>lack of tools</em>. To mitigate this problem, novel approaches are based on dynamic adaptation through an energy profiler module, energy policies, and energy adaptation APIs <a href="#biblioentry_13"> </a> <a href="#biblioentry_14"> </a>. The energy profiler module can recognize the system states and estimate the energy potentially demanded by an application.</p>
<p>Another example is method reallocation <a href="#biblioentry_31"> </a>, which refers to the analysis of a software system considering all the levels of the stack (<em>e.g.</em>, kernel, library, and source code level), and reorganizing the classes and methods through the levels of the stack, in a way in which they can be placed in the level where the energy consumption is minimal. As a limitation, this technique can be utilized only if the operating system and the software development environment allow application software developers to go through the different levels (<em>e.g.</em>, from source code level to kernel level). In a similar strategy, cloud offloading <a href="#biblioentry_1"> </a> is a technique in which heavy computations are sent to a remote computer; after the remote execution the result is sent back to the local machine. This approach aims to re-organize the implementation of the system at the source code level, thus saving energy by minimizing processing. Interestingly, when we asked if the respondents found any solution to overcome the energy-related problems, one of the respondents said that "<em>Offload intensive work to workers in the cloud</em>." However, this technique is only effective if the savings can compensate the extra energy toll required to send a computation through a network. Therefore, trade-offs exist and, as we have discussed in <a href="#section2"> </a>, different components have different energy usage characteristics.</p>
<p><em><strong>Measurement tools</strong><strong>.</strong></em> Some measurement tools include methods that use data collected from different system interfaces to assess the energy consumption at the application level. One example is the Running Average Power Limit (RAPL). This module enables architectures monitor energy consumption and store it in Machine-Specific Registers (MSRs<a href="#endnote_4"> </a>). Several energy-consumption studies are based on this module (e.g.,<a href="#biblioentry_30"> </a><a href="#biblioentry_2"> </a><a href="#biblioentry_25"> </a>). With such techniques, it is possible to profile a system and analyze, for instance, what are the system calls that have a major contribution to power dissipation <a href="#biblioentry_31"> </a> <a href="#biblioentry_2"> </a>. System calls, in particular, are being actively used for predicting and estimating energy consumption of a software system <a href="#biblioentry_43"> </a> <a href="#biblioentry_39"> </a> <a href="#biblioentry_40"> </a>.</p>
<p>Other tools leverage energy models. This strategy utilizes a model developed by physically measuring the energy consumption of a device <a href="#biblioentry_44"> </a> <a href="#biblioentry_1"> </a> <a href="#biblioentry_23"> </a>. Energy models have a higher level of confidence only when approximating the energy consumption on the hardware based on which the model was created. Other hardware architectures can only consider the model as a rough estimation.</p>
<p>Although there are already some software tools for energy measurement (<em>e.g., </em><a href="#biblioentry_23"> </a> <a href="#biblioentry_44"> </a>), such tools have well-known drawbacks. First, energy measurement tools may pay an additional overhead on energy consumption, mostly due to the sampling mechanism. Data acquisition (<em>i.e.</em>, sampling) is the result of the process of acquiring information from the surrounding environment, processing the data, and sending it to another collection point to be consumed. Therefore, sampling techniques might impact energy consumption. This poses a challenge, since a recent study provides evidence that a high sampling rate is necessary to obtain reliable information <a href="#biblioentry_42"> </a>. Even though this problem can be circumvented by employing software-based measurement approaches <a href="#biblioentry_2"> </a>, these approaches are often regarded as less rigorous than hardware-based ones.</p>
<p>Second, hardware- and software-based approaches often do not provide the granularity level that application software developers are interested in <a href="#biblioentry_22"> </a> <a href="#biblioentry_24"> </a>. For instance, there is no tool support to measure energy consumption per thread per system module. It is difficult to link the energy measurements across the running threads with fine-grained events that happen during program execution, such as method calls. To make matters worse, the tail energy --- <em>i.e.</em>, the high power state that remains long after the usage of a hardware component, such as the GPS <a href="#biblioentry_23"> </a> --- should be taken into consideration, even in the presence of context switches. As a result, there is a mismatch between the noise introduced by coarse-grained measurements and the tiny energy impact of methods calls. Still, in our survey, 11 respondents mentioned that measurement tools are among the most important energy-related features to have available in well-known IDEs.</p>
<p><em><strong>Static Analysis tools</strong><strong>.</strong></em> One of the main challenges of software energy consumption research is to bring analysis to the static level. Currently, software energy consumption instrumentation can only be conducted at runtime. This approach has several limitations, such as sophisticated (and expensive) hardware equipments <a href="#biblioentry_3"> </a> or applicability only to specific hardware configurations <a href="#biblioentry_2"> </a>. This fact has the potential of limiting the usability of software energy consumption tools.</p>
<p>Although there are few studies in this direction (<em>e.g.</em>, a static analysis technique for estimating the energy consumption of embedded programs <a href="#biblioentry_35"> </a> ), these tools (1) often combine static analysis with dynamic analysis techniques (<em>e.g.</em>, <a href="#biblioentry_23"> </a> <a href="#biblioentry_50"> </a>), which makes them hardware-dependent, and (2) do not exhibit maturity, nor the breadth of scope necessary for use in real software development. One of the main challenges for deriving static analysis tools for energy consumption is the need for a body of knowledge on how language constructs and design decisions impact energy consumption. Due to the emerging character of the field <a href="#biblioentry_6"> </a>, we believe that new empirical energy consumption studies will be conducted in the following years, which in turn will help researchers to create such static analysis tools.</p>
</section>
<section id="section8">
<h2>Software Maintenance</h2>
<p>We organize our discussion of software maintenance in terms of refactoring, reengineering, and visualization.</p>
<p><em><strong>Refactoring.</strong></em> Refactoring tools can take advantage of cutting-edge research and incorporate such knowledge into refactoring engines. However, as a researcher respondent said, "<em>There is a lot of work showing how different programming styles, techniques, structures influence the consumption, but there is still no real cataloging [..] based on these concrete software practices</em>". Although researchers have been speculating on this subject during the last years <a href="#biblioentry_37"> </a>, to the best of our knowledge, there is only a handful of studies that deals with the problem of introducing novel refactoring tools for improving the energy efficiency of a software system <a href="#biblioentry_12"> </a><a href="#biblioentry_38"> </a>. In one of these studies, the authors present a set of energy-efficiency guidelines that are specifically tailored for Android apps, such as location updates and resource leaks. When applied, the authors observed improvements of up to 29% of the overall energy consumption.</p>
<p>This lack of contributions is not related to a lack of opportunities, though. As mentioned before, there are several opportunities for application software developers to save energy by refactoring existing systems <a href="#biblioentry_29"> </a> <a href="#biblioentry_6"> </a>. As two examples, Pinto et al. <a href="#biblioentry_25"> </a> observed that just updating from <code>​Hashtable</code> to <code>​ConcurrentHashMap</code> in a Java program can yield a 3.5x energy savings. In particular, this transformation yields a 1.4x and a 9.2x energy savings in CPU and DRAM, respectively. As another example, Pathak <em>et al</em>. <a href="#biblioentry_11"> </a> observed that I/O operations consume more energy partly because of the tail energy phenomenon. According to the authors, this tail energy leak can be mitigated by bundling I/O operations together. These results have a clear implication: Tools to aid developers in quickly refactoring programs can be useful if energy is important.</p>
<p><em><strong>Reengineering.</strong></em> Differently from Refactoring tools, which are more localized, reengineering efforts can be broader in scope and have a systemwide impact on the structure of an application. As mentioned, method reallocation <a href="#biblioentry_31"> </a>  and method offloading <a href="#biblioentry_1"> </a> are two common strategies to implement reenginering energy-aware methods. This is corroborated by the work of Othman <em>et al.</em>, which found that up to 20% energy savings can be achieved by uploading tasks from mobile devices to fixed servers <a href="#biblioentry_36"> </a>. Using a different strategy, Manotas et al. <a href="#biblioentry_26"> </a> proposed SEEDS, a general decision-making framework for optimizing software energy consumption. The SEEDS framework can identify energy-inefficient uses of Java collections, and automate the process of selecting more efficient ones. Along the same lines, Fernandes <em>et al.</em> <a href="#biblioentry_41"> </a> developed a tool that leverages static and dynamic analysis to recommend the most energy-efficient data structures. Search-based software engineering approaches were used to reengineer a software system in order to minimize energy usage <a href="#biblioentry_27"> </a>, yielding an energy reduction of up to 25%. These approaches mitigate the problem of <em>lack of tools</em>.</p>
<p><em><strong>Visualization.</strong></em> Visualization techniques are useful to support the understanding of software systems in order to discover and analyze their anomalies. Li <em>et al.</em> <a href="#biblioentry_23"> </a> proposed a technique that overlays energy consumption information with application's source code. This technique colors different amount of energy consumed in a given line of code --- blue lines describe low energy consumption whereas red lines indicate high energy consumption. This visualization technique is fine-grained and works at the source code level. On the other hand, the study of Couto <em>et al</em>. <a href="#biblioentry_32"> </a> focuses on a coarser granularity: It identifies the energy consumption per method, and aggregates this energy in terms of classes, packages, and the whole software system. The result is presented in a sunburst diagram, which allows developers to easily and quickly identify the most energy inefficient parts of the code. These studies combine art and technology as a way to represent energy consumption. With a better understanding of the whole program energy behavior, such visualization techniques can be useful to mitigate both <em>lack of knowledge</em> and <em>lack of tools</em>.</p>
</section>
<section id="section9">
<h2>Software Design &amp; Construction</h2>
<p>Researchers have been studying different strategies for designing and constructing energy-efficient software <a href="#biblioentry_47"> </a><a href="#biblioentry_49"> </a><a href="#biblioentry_5"> </a><a href="#biblioentry_19"> </a><a href="#biblioentry_11"> </a>. These studies focus on understanding how a particular programming practice or design implementation might impact on energy consumption. To gain further confidence in the results, these studies often analyze dozens (<em>e.g.</em>, <a href="#biblioentry_15"> </a>), or even hundreds (<em>e.g., </em><a href="#biblioentry_49"> </a>), of software applications, and they mitigate the lack of knowledge by providing high-level guidelines for designing energy-efficient software. We organize our discussions of software design &amp; construction in terms of mobile, network, data structures, and parallel programming techniques.</p>
<p><em><strong>Mobile development.</strong></em> Linares-Vasquez <em>et al. </em><a href="#biblioentry_19"> </a> investigated API calls that might cause high energy consumption. For example, they observed that the method <code>​Activity.findViewById</code>, which is commonly used, is one of the most energy-consuming among the Android APIs. Similarly, Malik <em>et al.</em> <a href="#biblioentry_45"> </a> found that the <code>​BroadcastReceiver</code> and the <code>​Location</code> APIs are the most often discussed among Android energy questions on StackOverflow. Furthermore, since the display is one of the smartphone' most energy-intensive components <a href="#biblioentry_17"> </a>, Li <em>et al </em><a href="#biblioentry_5"> </a> discussed how to improve energy efficiency by favoring darker colors instead of lighter ones for smartphones with OLED displays. Using a search-based multi-objective approach, Linares-Vasquez <em>et al.</em> <a href="#biblioentry_21"> </a> automatically optimized energy consumption and contrast, while using consistent colors with respect to the original color palette. Oliveira Jr. <em>et al</em>. <a href="#biblioentry_29"> </a> analyzed the energy consumption of Android app development approaches, Java, JavaScript, and Java + C++, in both benchmarks and real apps. In both scenarios it was observed that different approaches have different impacts on energy. In particular, combining different approaches can yield more than an order of magnitude energy savings in compute-intensive apps.</p>
<p><em><strong>Network usage.</strong></em> Li <em>et al.</em> <a href="#biblioentry_49"> </a>  analyzed more than 400 real-world Android apps, and found that an HTTP request is the most energy-consuming operation of the network. In a followup study, the same authors observed that bulking HTTP requests is a good practice for energy saving <a href="#biblioentry_50"> </a>. Also regarding HTTP usage, Chowdhury <em>et al.</em> <a href="#biblioentry_4"> </a> observed that HTTP/2 is more energy efficient than its predecessor, HTTP/1.1, for networks with higher Round Trip time (RTTs). Since most mobile apps use network <a href="#biblioentry_49"> </a>, we expect more contributions on this direction. Besides of bulking requests, researchers can evaluate the benefits of, for instance, reducing transactions, compressing data, and appropriately handling errors to conserve energy.</p>
<p><em><strong>Data Structures.</strong></em> The energy behavior of different data structures, one of the building blocks of computer programming, have been extensively studied in the last few years <a href="#biblioentry_25"> </a> <a href="#biblioentry_26"> </a> <a href="#biblioentry_47"> </a> <a href="#biblioentry_30"> </a>. Hasan and colleagues <a href="#biblioentry_47"> </a> investigated data structures grouped with three interfaces (List, Set, and Map). Among the findings, they found that the position where an element is inserted in a list can greatly impact energy consumption. Pinto <em>et al.</em> <a href="#biblioentry_25"> </a> studied the same group of interfaces, but focused on thread-safe data structures. They also observed that using a newer version of a thread-safe data structure can yield a 2.19x energy savings when compared to the old associative implementation. Lima <em>et al</em>. <a href="#biblioentry_30"> </a> studied the energy consumption of data structures in concurrent functional programs. Although they found that there is no clear universal winner, in certain circumstances, choosing one data sharing primitive (MVar) over another (TMVar) can yield 60% energy savings.</p>
<p><em><strong>Parallel Programming.</strong></em> Parallel programming techniques have also been the subject of several studies. Pinto <em>et al. </em><a href="#biblioentry_3"> </a> observed that a high-level, work-stealing parallel framework is more energy-friendly when performing fine-grained CPU-intensive computations than a thread-based implementation. Still, Ribic and Liu proposed a set of runtime systems for improving the energy efficiency of fine-grained CPU-intensive computations <a href="#biblioentry_13"> </a><a href="#biblioentry_14"> </a>. To better leverage the energy savings reported by these studies, we believe they can be integrated with well-known runtime systems, such as the Java Virtual Machine (JVM). If so, the whole chain of programming languages, software systems, and end-users that rely on the JVM can benefit from these findings.</p>
<p>Although these studies provide a comprehensive set of findings with practical and timely implications and can be useful to mitigate the problem of lack of knowledge, they are far from covering the whole spectrum of programming language constructs and libraries.</p>
</section>
<section id="section10">
<h2>Software Quality &amp; Testing</h2>
<p>Here we organize our discussions in terms of software testing and software debugging techniques.</p>
<p><em><strong>Software Testing.</strong></em> Although there are several studies aimed at characterizing energy bugs (<em>e.g.</em>, <a href="#biblioentry_20"> </a>), there are relatively few studies that propose new energy-aware testing techniques <a href="#biblioentry_23"> </a><a href="#biblioentry_16"> </a><a href="#biblioentry_18"> </a>. Ding and colleagues <a href="#biblioentry_23"> </a> presented an energy-efficient testing suite minimization technique that can be used to perform post-deployment testing on embedded systems. Results suggest that the approach can promote a reduction of over 95% of the energy consumed by the original test suite. Similarly, Jabbarvand <em>et al. <a href="#biblioentry_16"> </a></em> present another test suite minimization approach, but focusing on Android apps. The authors reported a reduction of, on average, 84%, while maintaining the effectiveness for revealing bugs. Kan <a href="#biblioentry_18"> </a>  proposes a similar approach: To use DVFS to scale frequency down when running the test suites. Although some researchers argued that DVFS techniques can lead to increased energy consumption and performance loss <a href="#biblioentry_2"> </a>, the authors showed that important energy savings can be achieved. Banerjee <a href="#biblioentry_10"> </a> proposed a technique that generates test inputs that are likely to capture energy bugs. This technique focuses on creating tests that use I/O components, which are one of the primary sources of energy consumption in a smartphone <a href="#biblioentry_17"> </a><a href="#biblioentry_11"> </a>.</p>
<p>Followed by these promising initial results, we believe that new testing techniques will be evaluated in terms of energy consumption. At best, energy testing will become a research area. Several possible areas of interest can be envisioned. One of them is what we call "green assertions", that is, the possibility to define an energy budget where the test case asserts whether the computation satisfies that budget. The test fails if the energy consumed is greater than the suggested budget. For instance, the code snippet <code>​double maxEnergy = 200; assertTrue(render(), expected, maxEnergy);</code> defines that the <code>​render()</code> method should consume, at most, 200 Joules. This technique can be further improved to cover additional hardware characteristics, for instance, asserting whether the computation consumes 100 Joules due to network communication or 50 Joules due to the CPU.</p>
<p><em><strong>Software Debugging.</strong></em> Practitioners commonly use debugging tools to catch bugs in program formulation. However, debugging an energy-inefficient piece of code is more challenging than traditional debugging because such inefficiencies depend on the contextual information about where a program is running, such as the state of the hardware devices. In this regard, Banerjee and colleagues <a href="#biblioentry_12"> </a>  propose a framework for debugging energy consumption-related <em>field failures</em> in mobile apps. The authors found that tool support could localize energy bugs in a short amount of time, even for non-trivial Android apps. The authors observed energy savings of up to 29% after patching the energy bug. Pathak <em>et al.</em> <a href="#biblioentry_11"> </a> propose <em>eprof</em>, a fine-grained profiling energy consumption technique for applications running on smartphones. Similar to the work of Banerjee and colleagues <a href="#biblioentry_10"> </a>, Pathak <em>et al.</em> focus on understanding and monitoring system calls that are related to I/O operations. As a results, they found that most of the energy consumed in free apps is related to third-party advertisement modules (which can be responsible for up to 75% of the overall energy consumed by an app). Using a collaborative black-box approach, Oliner <em>et al.</em> <a href="#biblioentry_9"> </a> propose a method for diagnosing anomalies, estimating their severity, and identifing the device features that lead to the anomaly. Using feedback received by the proposed tool, end users improved their battery life by 21%.</p>
<p>We believe that debugging tools will have the capability of inspecting the energy consumption of fine-grained program constructs during runtime, as well as their common ability to identify which value was attributed to a given variable. Debugging tools can go further and highlight the CPU-intensive lines of code, or the memory-intensive methods, in a way that developers can refactor them in an energy-savvy manner. Novel energy-related testing and debugging tools can mitigate the lack of tools.</p>
</section>
</section>
<section id="section11">
<h1>Conclusions</h1>
<p>Energy consumption is a ubiquitous problem and the years to come will require developers to be even more aware of it. However, developers currently do not fully understand how to write, maintain, and evolve energy-efficient software systems. In this study we suggest that this is primarily due to two problems: the <em>lack of knowledge</em> and the <em>lack of tools</em>. With these problems in mind, this paper reviews most of the recent energy-related contributions in the software engineering community. We discuss how software energy consumption research is evolving to mitigate these two problems and, when appropriate, we highlight key research gaps that need better attention.</p>
</section>
<section id="doc-bibliography" role="doc-bibliography">
<h1>References</h1>
<ul>
<li role="doc-biblioentry" id="biblioentry_8">
<p>A. Abran, P. Bourque, R. Dupuis, and J. W. Moore, editors. Guide to the Software Engineering Body of Knowledge - SWEBOK. 2001</p>
</li>
<li role="doc-biblioentry" id="biblioentry_12">
<p>A. Banerjee and A. Roychoudhury. Automated re-factoring of android apps to enhance energy-efficiency. In MOBILESoft , pages 139–150, 2016</p>
</li>
<li role="doc-biblioentry" id="biblioentry_10">
<p>A. Banerjee, L. K. Chong, S. Chattopadhyay, and A. Roychoudhury. Detecting energy bugs and hotspots in mobile apps. In ESEC/FSE, pages 588–598, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_17">
<p>A. Carroll and G. Heiser. An analysis of power consumption in a smartphone. In USENIX, 2010</p>
</li>
<li role="doc-biblioentry" id="biblioentry_44">
<p>A. Hindle, A. Wilson, K. Rasmussen, E. J. Barlow, J. C. Campbell, and S. Romansky. Greenminer: A hardware based mining software repositories software energy consumption framework. In MSR, pages 12–21, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_9">
<p>A. J. Oliner, A. P. Iyer, I. Stoica, E. Lagerspetz, and S. Tarkoma. Carat: Collaborative energy diagnosis for mobile devices. In SenSys, pages 10:1–10:14, 2013.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_20">
<p>A. Pathak, A. Jindal, Y. C. Hu, and S. P. Midkiff. What is keeping my phone awake?: characterizing and detecting no-sleep energy bugs in smartphone apps. In MobiSys, pages 267–280, 2012</p>
</li>
<li role="doc-biblioentry" id="biblioentry_11">
<p>A. Pathak, Y. C. Hu, and M. Zhang. Where is the energy spent inside my app?: Fine grained energy accounting on smartphones with eprof. In EuroSys, pages 29–42, 2012.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_41">
<p>B. Fernandes, G. Pinto, and F. Castor. Assisting non-specialist developers to build energy-efficient software. In  ICSE Companion, 2017.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_27">
<p>B. R. Bruce, J. Petke, and M. Harman. Reducing energy consumption using genetic improvement. In GECCO, pages 1327–1334, 2015</p>
</li>
<li role="doc-biblioentry" id="biblioentry_33">
<p>C. Pang, A. Hindle, B. Adams, and A. E. Hassan. What do programmers know about software energy consumption? IEEE Software, 33(3):83–89, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_48">
<p>D. Li and W. G. J. Halfond. An investigation into energy-saving programming practices for android smartphone app development. In GREENS, pages 46–53, 2014</p>
</li>
<li role="doc-biblioentry" id="biblioentry_49">
<p>D. Li, S. Hao, J. Gui, and W. G. J. Halfond. An empirical study of the energy consumption of android applications. In ICSME, pages 121–130, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_23">
<p>D. Li, Y. Jin, C. Sahin, J. Clause, and W. G. J. Halfond. Integrated energy-directed test suite optimization. In ISSTA, pages 339–350, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_50">
<p>D. Li, Y. Lyu, J. Gui, and W. G. J. Halfond. Automated energy optimization of http requests for mobile applications. In ICSE, pages 249–260, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_5">
<p>D. Li, Y. Lyu, J. Gui, and W. G. J. Halfond. Automated energy optimization of http requests for mobile applications. In ICSE, pages 249–260, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_34">
<p>E. Gelenbe and Y. Caseau. The impact of information technology on energy consumption and carbon emissions. Ubiquity, 2015(June):1:1–1:15, June 2015</p>
</li>
<li role="doc-biblioentry" id="biblioentry_28">
<p>E. Murphy-Hill, T. Zimmermann, and N. Nagappan. Cowboys, ankle sprains, and keepers of quality: How is video game development different from software development? In ICSE, pages 1–11, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_18">
<p>E. Y. Y. Kan. Energy efficiency in testing and regression testing – a comparison of dvfs techniques. In QSIC, pages 280–283, 2013.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_22">
<p>G. Pinto, F. Castor, and Y. D. Liu. Mining questions about software energy consumption. In MSR, pages 22–31, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_3">
<p>G. Pinto, F. Castor, and Y. D. Liu. Understanding energy behaviors of thread management constructs. In OOPSLA, pages 345–360, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_6">
<p>G. Pinto, F. Soares-Neto, and F. Castor. Refactoring for energy efficiency: A reflection on the state of the art. In GREENS, 2015.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_25">
<p>G. Pinto, K. Liu, F. Castor, and Y. D. Liu. A comprehensive study on the energy efficiency of java thread-safe collections. In ICSME, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_46">
<p>H. Khalid, E. Shihab, M. Nagappan, and A. E. Hassan. What do mobile app users complain about? IEEE Software, 32(3):70–77, 2015.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_45">
<p>H. Malik, P. Zhao, and M. W. Godfrey. Going green: An exploratory analysis of energy-related questions. In MSR, pages 418–421, 2015.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_14">
<p>H. Ribic and Y. D. Liu. Aequitas: Coordinated energy management across parallel applications. In ICS ’16, pages 4:1–4:12, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_13">
<p>H. Ribic and Y. D. Liu. Energy-efficient work-stealing language runtimes. In ASPLOS, pages 513–528, 2014</p>
</li>
<li role="doc-biblioentry" id="biblioentry_24">
<p>I. Manotas, C. Bird, R. Zhang, D. Shepherd, C. Jaspan, C. Sadowski, L. Pollock, and J. Clause. An empirical study of practitioners’ perspectives on green software engineering. In ICSE, pages 237–248, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_26">
<p>I. Manotas, L. Pollock, and J. Clause. Seeds: A software engineer’s energy-optimization decision support framework. In ICSE, pages 503–514, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_7">
<p>I. Moura, G. Pinto, F. Ebert, and F. Castor. Mining energy-aware commits. In MSR, pages 56–67, 2015.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_39">
<p>K. Aggarwal, A. Hindle, and E. Stroulia. GreenAdvisor: A tool for analyzing the impact of software evolution on energy consumption. In ICSME, pages 311–320, Sept 2015.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_43">
<p>K. Aggarwal, C. Zhang, J. C. Campbell, A. Hindle, and E. Stroulia. The power of system call traces: Predicting the software energy consumption impact of changes. In CASCON, pages 219–233, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_2">
<p>K. Liu, G. Pinto, and Y. D. Liu. Data-oriented characterization of application-level energy optimization. In FASE, 2015.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_31">
<p>L. Corral, A. B. Georgiev, A. Sillitti, and G. Succi. Method reallocation to reduce energy consumption: an implementation in android OS. In SAC, pages 1213–1218, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_38">
<p>L. Cruz, R. Abreu, and J.-N. Rouvignac. Leafactor: Improving energy efficiency of android apps via automatic refactoring. In MobileSoft, 2017.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_30">
<p>L. G. Lima, F. Soares-Neto, P. Lieuthier, F. Castor, G. Melfe, and J. P. Fernandes. Haskell in green land: Analyzing the energy behavior of a purely functional language. In SANER, pages 517–528, 2016</p>
</li>
<li role="doc-biblioentry" id="biblioentry_32">
<p>M. Couto, T. Carção, J. Cunha, J. P. Fernandes, and J. Saraiva. Detecting anomalous energy consumption in android applications. In SBLP, pages 77–91, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_15">
<p>M. Kambadur and M. A. Kim. An experimental survey of energy management across the stack. In OOPSLA, pages 329–344, 2014.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_19">
<p>M. Linares-Vásquez, G. Bavota, C. Bernal-Cárdenas, R. Oliveto, M. Di Penta, and D. Poshyvanyk. Mining energy-greedy api usage patterns in android apps: An empirical study. In MSR, pages 2–11, 2014</p>
</li>
<li role="doc-biblioentry" id="biblioentry_21">
<p>M. Linares-Vásquez, G. Bavota, C. E. B. Cárdenas, R. Oliveto, M. Di Penta, and D. Poshyvanyk. Optimizing energy consumption of GUIs in android apps: A multi-objective approach. In ESEC/FSE, pages 143–154, 2015.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_36">
<p>M. Othman and S. Hailes. Power conservation strategy for mobile computers using load sharing. SIGMOBILE Mob. Comput. Commun. Rev., 2(1):44–51, Jan. 1998.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_16">
<p>R. Jabbarvand, A. Sadeghi, H. Bagheri, and S. Malek. Energy-aware test-suite minimization for android apps. In ISSTA, pages 425–436, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_42">
<p>R. Saborido, V. Arnaoudova, G. Beltrame, F. Khomh, and G. Antoniol. On the impact of sampling frequency on software energy measurements. PeerJ PrePrints, 3:e1219, 2015.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_40">
<p>S. A. Chowdhury and A. Hindle. Greenoracle: estimating software energy consumption with energy measurement corpora. In MSR, pages 49–60, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_4">
<p>S. A. Chowdhury, V. Sapra, and A. Hindle. Client-side energy efficiency of HTTP/2 for web and mobile app developers. In SANER, pages 529–540, 2016.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_37">
<p>S. Fraser, E. Murphy-Hill, W. Wild, J. Yoder, and B. Q. Zhu. Going green with refactoring: Sustaining the "worldwide virtual machine". In OOPSLA, pages 171–174, 2011.</p>
</li>
<li role="doc-biblioentry" id="biblioentry_47">
<p>S. Hasan, Z. King, M. Hafiz, M. Sayagh, B. Adams, and A. Hindle. Energy profiles of java collections classes. In ICSE, pages 225–236, 2016</p>
</li>
<li role="doc-biblioentry" id="biblioentry_35">
<p>U. Liqat, S. Kerrison, A. Serrano, K. Georgiou, P. López-García, N. Grech, M. V. Hermenegildo, and K. Eder. Energy consumption analysis of programs based on XMOS isa-level models. In LOPSTR, pages 72–90, 2013</p>
</li>
<li role="doc-biblioentry" id="biblioentry_29">
<p>W. O. Jr., R. Oliveira, and F. Castor. A study on the energy consumption of android app development approaches. In MSR, Buenos Aires, Argentina, 2017</p>
</li>
<li role="doc-biblioentry" id="biblioentry_1">
<p>Y. Kwon and E. Tilevich. Reducing the energy consumption of mobile applications behind the scenes. In ICSM, pages 170–179, 2013.<span style="font-size: 12pt;"> </span></p>
</li>
</ul>
</section>
<section id="doc-endnotes" role="doc-endnotes">

<section role="doc-endnote" id="endnote_1">
<p><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/index.html#//apple_ref/doc/uid/TP40013929" rel="noopener">https://developer.apple.com/library/content/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/index.html#//apple_ref/doc/uid/TP40013929</a></p>
</section>
<section role="doc-endnote" id="endnote_2">
<p><a href="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/EnergyGuide-iOS/MonitorEnergyWithXcode.html" rel="noopener">https://developer.apple.com/library/ios/documentation/Performance/Conceptual/EnergyGuide-iOS/MonitorEnergyWithXcode.html</a></p>
</section>
<section role="doc-endnote" id="endnote_3">
<p><a href="https://github.com/alobo/SerialGSM/commit/c616b950" rel="noopener">https://github.com/alobo/SerialGSM/commit/c616b950</a></p>
</section>
<section role="doc-endnote" id="endnote_4">
<p><a href="https://01.org/msr-tools/overview" rel="noopener">https://01.org/msr-tools/overview</a></p>
</section>
</section></body></html>