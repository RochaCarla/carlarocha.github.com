<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-14T04:13:31-03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gustavo Pinto</title><subtitle>Professional webpage for Gustavo Pinto.</subtitle><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><entry><title type="html">What researchers think about Rapid Reviews?</title><link href="http://localhost:4000/blog/what-researchers-think-about-rapid-reviews/" rel="alternate" type="text/html" title="What researchers think about Rapid Reviews?" /><published>2019-07-30T00:00:00-03:00</published><updated>2019-07-30T00:00:00-03:00</updated><id>http://localhost:4000/blog/what-researchers-think-about-rapid-reviews</id><content type="html" xml:base="http://localhost:4000/blog/what-researchers-think-about-rapid-reviews/">&lt;p&gt;Rapid Reviews (RRs) are lightweight secondary studies intended to provide evidence to support informed decision making. Different than Systematic Literature Reviews (SLRs) that usually take several months (or even years) to be done, RRs are conducted in time frames more likely to meet practitioners’ demands (in weeks or in a month, instead of months or a year) and demand the involvement of few, sometimes only one researcher, reducing the costs to deliver evidence.&lt;/p&gt;

&lt;p&gt;Although RRs are a rising research method in the medical domain, they are barely known by the software engineering community. In a &lt;a href=&quot;http://gustavopinto.org/lost+found/ease2018.pdf&quot;&gt;previous study&lt;/a&gt; we observed that practitioners were very supportive towards the use of RRs. Unfortunately, the perceptions of researchers, who usually are in charge of conducting the RRs, is still unknown. Considering the recent movements in software engineering to increase the quality of SLRs, we believe that the methodological concessions of the RRs could provoke some controversy in the software engineering research arena.&lt;/p&gt;

&lt;p&gt;Therefore, it was not clear to us whether researchers would embrace RRs. On the one hand, although RRs can speed up the knowledge transfer process to practice (and initial results suggest that practitioners appreciate it), researchers may be skeptical to adopt RRs due to methodological concessions (or afraid to have their papers rejected when using a not that rigorous methodology) .&lt;/p&gt;

&lt;p&gt;In order to investigate the software engineering researchers perception on the potential use of RRs, we invited a group of 37 SE researchers and asked them to analyze a predefined set of 50 statements regarding RRs, and rank them according to what extent they agree with each statement. To conduct this analysis, we relied on a &lt;a href=&quot;https://qmethod.org/&quot;&gt;Q-Methodology&lt;/a&gt;. This approach may sound like surveys, but it is intrinsically different. More concretely, using this method, the participants are required to prioritize their perceptions, avoiding bias in their responses (e.g., some participants might be more positive than others).&lt;/p&gt;

&lt;p&gt;Using this methodology, we revealed four different perceptions about RRs. They are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;The Picky:&lt;/strong&gt; The SE researcher does not believe that RRs can deliver high quality evidence;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The Unconvinced&lt;/strong&gt;: The SE researcher needs more evidence about Rapid Reviews;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The Pragmatic:&lt;/strong&gt; The SE researcher might conduct some RRs in specific scenarios where they are appropriate.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The Enthusiastic:&lt;/strong&gt; The SE researcher is willing to conduct RRs, but only if minimum standards are meet;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this paper, we understood that some researchers are willing to experiment with RRs, although some of them are still very conservative. However, with this study and our &lt;a href=&quot;http://gustavopinto.org/lost+found/ease2018.pdf&quot;&gt;initial results&lt;/a&gt; (and eventual other research works that may go along these lines), we believe other researchers may become motivated to embrace this methodology.&lt;/p&gt;

&lt;p&gt;If you want to know more about this study, you can read the preprint available &lt;a href=&quot;https://arxiv.org/abs/1906.11351&quot;&gt;here&lt;/a&gt;. The tool the implements the Q-Methodology is also available &lt;a href=&quot;https://github.com/bfsc/qmethod&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">A summary of an ESEM'19 paper</summary></entry><entry><title type="html">Detecting and Reporting Object-Relational Mapping Problems</title><link href="http://localhost:4000/blog/detecting-and-reporting-orm-problems/" rel="alternate" type="text/html" title="Detecting and Reporting Object-Relational Mapping Problems" /><published>2019-07-26T00:00:00-03:00</published><updated>2019-07-26T00:00:00-03:00</updated><id>http://localhost:4000/blog/detecting-and-reporting-orm-problems</id><content type="html" xml:base="http://localhost:4000/blog/detecting-and-reporting-orm-problems/">&lt;p&gt;Developers often take advantage of Object-Relation Mapping (ORM) frameworks to
provide a conceptual abstraction between objects in object-oriented languages
and data stored in the underlying database. These ORM frameworks operate between
object-oriented architecture system and the relational environment, creating a
“virtual object database” that can be handled from within the programming language.&lt;/p&gt;

&lt;p&gt;The good thing about these frameworks is that they greatly reduces the effort of
not only communicating with a database but also dealing with basic database
operations (e.g., insert, update, read, and delete), since changes to objects
are automatically propagated to the corresponding database records. As a
consequence, developers do not need to spend time and effort creating operations
to communicate with the database, over and over again.&lt;/p&gt;

&lt;p&gt;The bad thing, however, is the fact that developers may underused or overused
these frameworks. For instance, a &lt;a href=&quot;https://petertsehsun.github.io/papers/peter_tse2016.pdf&quot;&gt;study has found&lt;/a&gt; that when these frameworks are misused, they can deteriorate a performance of a software application.&lt;/p&gt;

&lt;p&gt;Although ORM frameworks are widespread in the software development industry, it
may come as a no surprise that developers are facing many problems with them.
A student of mine, who also works in a R&amp;amp;D institute, mentioned to me that they
are dealing with the same ORM problems for many years in a row. After getting
tired of having to fix them manually, my student created a tool that finds an
eventual ORM problem, and highlights it to the developer. The tool searches for 12
kinds of ORM problems, such as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Misspelling the names of schemas, tables, or columns (e.g., names with accents);&lt;/li&gt;
  &lt;li&gt;Forgetting to create constraints (e.g., did not create a foreign key constraint);&lt;/li&gt;
  &lt;li&gt;Mismatching JPA annotations (e.g., using @Column when a @JoinColumn was needed);&lt;/li&gt;
  &lt;li&gt;Forgetting to use an important annotation (e.g., a @Temporal annotation in a date
datatype, a @Enumared in an Enum datatype, or a @Table in a class).&lt;/li&gt;
  &lt;li&gt;Forgetting to implement the Serializable interface&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The tool consists of static analyzing ORM code looking for the ORM problems.
We use bytecode instrumentation to (1) obtain the ORM code and to (2) create
several assertions that check whether the ORM code contains one (or more) of the
curated ORM problems. We also provide enhanced error messages that aid developers
to fix the ORM problem found. After cataloging 12 mapping problems, and providing a
tool to automatically identify and report them, we conduct a developer experience
(DX) study with 13 participants to better understand the framework’s
limitations and eventual points for improvements.&lt;/p&gt;

&lt;p&gt;We observed several &lt;em&gt;benefits&lt;/em&gt; with the usage of our tool. All the participants
agreed that the enhanced error messages helped them to conclude the experiments.
One particularly interesting finding is that two participants finished the tasks
without any ORM experience. When we interviewed them, we perceived that they were
able to accomplish the task by following the suggestions of the enhanced error
messages. There were also some &lt;em&gt;challenges&lt;/em&gt;. We perceived that the tools’
documentation was not appropriated, since some participants had a hard time to
use some custom annotations. However, although the documentation was not
sufficient in some points, all participants were able to complete all the tasks.
Interestingly, my student did not experience these two problems in the company. This
may be  explained due to the fact that the architect of the tool as always
available to answer eventual questions.&lt;/p&gt;

&lt;p&gt;Finally, one experienced developer may argue that this tool might not be relevant
today. However, when browsing Q&amp;amp;A websites, we still see these problems occurring.
For instance, &lt;a href=&quot;stackoverflow.com/q/55466284&quot;&gt;this question&lt;/a&gt;, asked in April 2019,
could be fixed by our tool.&lt;/p&gt;

&lt;p&gt;The tool is not yet available, since my student is still dealing with copyright
issues in this company (he wrote the tool while working there). I will update
this blog post when he gets over it. If you want to read the complete report,
click &lt;a href=&quot;http://gustavopinto.github.io/lost+found/esem2019-industry.pdf&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;BTW: This paper was my very first submission to an industry track and my very fist
academia-industry collaboration. Lesson learned: if you happen to have students
that work in the industry, instead of suggesting your problems to them, ask them
what are their problems.&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">A summary of an ESEM'19 paper (industry track)</summary></entry><entry><title type="html">Resumo da disciplina de Tópicos Especiais em Software Livre</title><link href="http://localhost:4000/blog/resumo-da-disciplina-topicos-especiais-em-software-livre/" rel="alternate" type="text/html" title="Resumo da disciplina de Tópicos Especiais em Software Livre" /><published>2019-07-16T00:00:00-03:00</published><updated>2019-07-16T00:00:00-03:00</updated><id>http://localhost:4000/blog/resumo-da-disciplina-topicos-especiais-em-software-livre</id><content type="html" xml:base="http://localhost:4000/blog/resumo-da-disciplina-topicos-especiais-em-software-livre/">&lt;p&gt;No primeiro semestre de 2019, em conjunto com &lt;a href=&quot;filipesaraiva.info/&quot;&gt;Filipe Saraiva&lt;/a&gt;, ministramos a disciplina de
&lt;a href=&quot;http://github.com/gustavopinto/tesl&quot;&gt;Tópicos Especiais em Software Livre (TESL)&lt;/a&gt; para alunos da graduação e pós-graduação
da UFPA. Como tanto o Filipe quanto eu temos bastante interesse em software
livre, o Filipe com um viés mais prático, e eu no sentido de pesquisa, já
estavamos pensando em ofertar essa disciplina há algum tempo. No entanto, dado
uma necessidade interna da nossa faculdade (alguns professores afastados, outros
recém aposentados, resultando em um défict de professores), decidimos meio que de
último minuto ofertar a disciplina.&lt;/p&gt;

&lt;p&gt;Como fizemos isso sem muito planejamento, a disciplina nasceu e cresceu de forma
meio orgânica. Decidimos sobre uma agenda, e fomos produzindo o material sob
demanda. Dentre os tópicos abordados estão: documentação, licenças, gerenciamento
de código e requisitos, boas práticas de codificação, e métricas de código fonte.&lt;/p&gt;

&lt;p&gt;Como foi a primeira vez que a disciplina foi ofertada na UFPA, houve um interesse
muito grande por parte dos alunos, tanto que rapidamente as vagas se esgotaram
(tanto para a graduação quanto para a pós-graduação). Tivemos também que abrir vagas
excedentes para alunos especiais (aqueles que não estão regularmente matriculados
em no programa de pós-graduação). Somando graduação e pós, acredito que cerca
de 60 alunos se matricularam para essa disciplina. Para alguns esse número pode
parecer pequeno, mas, para nós, é um número muito grande de alunos (tanto que
tivemos que procurar um espaço externo a nossa faculdade para as aulas). Na nossa
faculdade, turmas grandes tem cerca de 35–40 alunos (e não é incomum turmas de
~15 alunos). Mas isso é história para outo post de blog.&lt;/p&gt;

&lt;p&gt;Fiquei bastante feliz pelo interesse dos alunos em se matricular na disciplina
(revelando uma eventual carência na área). Ao longo da disciplina, no entanto,
o número de alunos foi diminuindo rapidamente. A sala, que ficava apertada nas
primeiras aulas, começou a ficar folgada ao longo do semestre. Há vários fatores
que podem explicar a desistência dos alunos, dos quais dois deles valem a pena
pensar um pouco mais. O primeiro é que se trata de uma disciplina optativa, logo
os alunos tem menos resposabilidade em concluir, uma vez que eles poderiam cursar
outra(s) optativa(s) em um outro semestre, e creditar a necessidade dessa matéria.
Outro ponto é dado o material completo da disciplina não estar disponível durante
o período de matrícula (os alunos tinham acesso somente a ementa). Logo, é possível
que alguns alunos estivessem esperando um outro tipo de disciplina. Enfim.&lt;/p&gt;

&lt;p&gt;Ao meu ver, o cerne dessa disciplina é que o aluno deveria sair dela com algumas
contribuições feitas em alguns projetos de software livre. Não é necessário somente
usar um software livre, é também necessário entender, usar e modificar. Ao longo
das aulas, os alunos tiveram várias pequenas atividades para entender como funciona
um projeto de software livre, como por exemplo entender a importância das
comunidades, pra que serve uma licença, onde pedir ajuda, etc. Tivemos também
algumas palestras convidadas de membros ativos de projetos de software livre,
como o &lt;a href=&quot;http://softwarelivre.org/terceiro&quot;&gt;Antônio Terceiro&lt;/a&gt;, contribuidor do Debian, e o &lt;a href=&quot;https://feaneron.com&quot;&gt;George Stavracas&lt;/a&gt;, contribuidor
do GNOME. Como no início também pensávamos que os alunos poderiam produzir artigos
científicos ao fim da disciplian (e a vários alunos da pós-graduação estavam
matriculanos), também convidamos o &lt;a href=&quot;www.igor.pro.br&quot;&gt;Igor Steinmacher&lt;/a&gt;, que conduz pesquisa
nesse tópico. Nesse primeiro momento, foi
colocado pouca enfâse na contribuição em sí, e mais no processo de criação e
evolução de um projeto de software livre. Por um lado isso nos pareceu adequado,
já que é muito importante entender o contexto antes de se envolver, de fato. Por
outro lado, isso tardiou a contribuição dos alunos nos projetos.&lt;/p&gt;

&lt;p&gt;Na segunda parte da disciplina, os alunos deveriam usar os conhecimentos adquiridos
para procurar um projeto de software livre e fazer uma contribuição. Algumas
contribuições na verdade. Embora não mandatório, era esperado que todos os alunos
fizessem pelo menos uma contribuição de código de código pequena (por exemplo,
uma refatoração), embora outras  atividades estivessem disponíveis para os alunos
(ver lista completa e pontuação sugerarida &lt;a href=&quot;https://github.com/gustavopinto/tesl/blob/master/trabalho-final.md&quot;&gt;aqui&lt;/a&gt;).
Como tivemos 11 aulas expositivias (somado com duas paralizações e um feriado)
os alunos tiveram em torno de três a quatro semanas para fazer as contribuições
nos projetos. Refletindo agora, é notório que a disciplina ficou bem desbalanceada.
No entanto, embora eu concorde que alguns tópicos poderiam ser removidos da ementa
da disciplina, eu acho que seria muito difícil equalizar o tempo dedicado nas aulas
e nos projetos. Ponto para debate.&lt;/p&gt;

&lt;p&gt;De toda forma, mesmo que o tempo para realizar os projetos tenha sido relativamente
curto, acredito que todos os alunos conseguiram realizar alguma contribuição.
Algumas contribuições, inclusive, foram bem significativas, como por exemplo, um
novo algoritmo para o &lt;a href=&quot;https://github.com/scikit-learn/scikit-learn/pull/14239&quot;&gt;scikit-learn&lt;/a&gt;,
criação de nova regra no &lt;a href=&quot;https://github.com/sindresorhus/eslint-plugin-unicorn/pull/302&quot;&gt;ESLint&lt;/a&gt;,
ou um novo layout para o &lt;a href=&quot;https://github.com/halogenica/beautifulhugo/pull/287&quot;&gt;beautifulhugo&lt;/a&gt;.
Vários outros alunos fizeram contribuições menores, mas também bastante interessantes
como &lt;a href=&quot;https://github.com/GoogleCloudPlatform/oozie-to-airflow/pull/272&quot;&gt;refatorações&lt;/a&gt;, parsing de &lt;a href=&quot;https://github.com/edsu/pymarc/pull/137&quot;&gt;arquivo JSON&lt;/a&gt;, além de &lt;a href=&quot;https://github.com/python-gsoc/python-blogs/pull/240&quot;&gt;traduções&lt;/a&gt;, e &lt;a href=&quot;https://github.com/CiviWiki/OpenCiviWiki/pull/537&quot;&gt;bug reports&lt;/a&gt;. No total, os alunos
fizeram mais de 60 contribuições em projetos de software livre. Durante as
apresentações dos projetos, vários alunos mencionaram que a disciplina ajudou
a fazer a primeira contribuição em um projeto de software livre (alguns alunos
estavam inclusive bem felizes por causa disso).&lt;/p&gt;

&lt;p&gt;Ao fim da disciplina, lancei um questionário pra avaliar a percepção dos alunos
com relação a disciplina. 17 alunos responderam. Dentre os quais, 65% nunca haviam
contribuido com projetos de software livre antes (apenas um era contribuidor ativo).
88% dos alunos mostraram interesse em continuar contribuindo com software livre
após a disciplina. Quando perguntados quais as chances de realizar as contribuições
feitas se não tivessem cursado a disciplina 71% disseram que era “improvável” ou
“muito improvável”. 88% dos alunos recomendariam a disciplina para algum colega.&lt;/p&gt;

&lt;p&gt;Ainda sobre o questionário, alguns alunos acharam particularmente interessante
assuntos sobre licenças, sobre o funcionamento das comundiades, ou sobre
engajamento nos projetos. Um aluno mencionou que achou interessante saber&lt;br /&gt;
“Que é possível ganhar dinheiro com software livre”. Não sei se foi o mesmo aluno,
mas um aluno da disciplina procurou projetos e issues que eram financiadas. Esse
mesmo aluno comentou comigo que recebeu mais dinheiro contribuindo com os projetos
do que em 2 ou 3 meses de estágio. MASSA!
Sobre os tópicos que deveriam ser abordados (mas que não foram), alguns alunos
mencionaram que é importante falar mais sobre o git e o github durante a disciplina.
Nós simplesmente assumimos que esses assuntos seriam rapidamente absorvidos pelos
alunos, mas não parece ser o caso. Inclusive, logo no começo das aulas, foi
perceptível que vários alunos tiveram problemas em como usar o sistema de
pull-requests nos exercícios.&lt;/p&gt;

&lt;p&gt;Com relação as dificuldades para contribuir, alguns alunos
reportaram que tiveram dificuldades para enteder as guideslines do projeto, para
seguir os padrões de código adoados, ou até mesmo no processo de revisão. Vários
alunos reportaram que tiveram dificudlades para encontrar projetos para fazer
contribuições. Isso é particularmente interessante, visto que muito se tem feito
nos últimos anos para fazer com novatos embarquem em projetos de software livre,
mas a barreira de entrada ainda parece ser muito grande. Recentemente, inclusive,
Karl Fogel &lt;a href=&quot;https://twitter.com/kfogel/status/1144648353873051649&quot;&gt;questionou no Twitter&lt;/a&gt;
quais as ações que as pessoas fazem para se envolver com software liver. Meu, se
até o Karl Fogel tem essa dúvida, o que dirá os meus alunos… Para exemplificar,
usando as palavras de um aluno, coloco aqui as dificuldades por ele encontradas:&lt;/p&gt;

&lt;p&gt;“Contribuições de documentações são relativamente simples de encontrar e realizar, reportar bugs também não é uma tarefa tão difícil, visto que no decorrer do dia nos deparamos com pequenos bugs em nossas ferramentas. O grande problema é contribuir com código: Não estar familiarizado com a estrutura de um projeto é uma grande barreira, ao vasculhar o código fonte serão encontradas diversas ferramentas e bibliotecas sendo utilizadas em conjunto com as técnicas de programação (OOP, Data Structures), e para alunos que nunca desenvolveram nenhum projeto fora da universidade pode ser frustrante entender essa junção de utilização de ferramentas + conceitos. Acredito que a melhor forma de contornar essa barreira seria influenciando os alunos a procurarem contribuições a serem feitas desde o inicio da disciplina, isso faz com que eles possam amadurecer ao longo da disciplina.”&lt;/p&gt;

&lt;p&gt;Para finalizar, gostaria de agradecer o Filipe Saraiva, que foi quem lançou a
proposta e abraçou a causa junto comigo. Agradecer também aos convidados,
Antônio Terceiro, George Stavracas e Igor Steinmacher, que acharam tempo em suas
agendas apertadas para dar uma palestra para os alunos, e também ao &lt;a href=&quot;https://www.mauricioaniche.com/&quot;&gt;Mauricio Aniche&lt;/a&gt;
que gentilmente disponibilizou algumas cópias de alguns de seus livros que foram
enviadas para os alunos que tiveram excelente desempenho na disciplina. Agradeço
também ao nosso monitor, &lt;a href=&quot;https://github.com/felipenazario&quot;&gt;Marcos Nazário&lt;/a&gt;, que assumiu três aulas (uma delas nem
era de sua responsabilidade). Por fim, agradecer também aos alunos que participaram
da disciplina! Sem dúvida, nada disso teria acontecido se não fosse vocês. Valeu!&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">Desafios e lições aprendidas</summary></entry><entry><title type="html">Continuous Integration Theater</title><link href="http://localhost:4000/blog/continuous-integration-theater/" rel="alternate" type="text/html" title="Continuous Integration Theater" /><published>2019-07-10T00:00:00-03:00</published><updated>2019-07-10T00:00:00-03:00</updated><id>http://localhost:4000/blog/continuous-integration-theater</id><content type="html" xml:base="http://localhost:4000/blog/continuous-integration-theater/">&lt;p&gt;According to &lt;a href=&quot;https://www.gocd.org/2017/05/16/its-not-CI-its-CI-theatre.html&quot;&gt;this post&lt;/a&gt;,
“CI theatre describes the illusion of practising continuous integration (CI)
while not really practising it.” Common failure modes include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;running CI against a shared mainline but with infrequent commits, so integration isn’t really continuous;&lt;/li&gt;
  &lt;li&gt;running a build with poor test coverage;&lt;/li&gt;
  &lt;li&gt;allowing the build to stay red for long periods;&lt;/li&gt;
  &lt;li&gt;running CI against feature branches which results in continuous isolation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although practitioners have been discussing about this for a long time (for instance,
the ThoughtWorks tech radar recently recommended putting this antipattern on
“Hold” two years ago), little research has been devoted to understand how does this
antipattern  happens in the real world. We dedicated an entire paper to study
how common are open source projects that face CI theater. We explored four research questions:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RQ1. How common is running CI in the master branch but with infrequent commits?&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;Rationale.&lt;/strong&gt; One of the main advantages of CI systems is that they decrease the pain of merging new changes. This relief comes from the practice of merging continuously. However, sometimes software engineers opt not to integrate continuously (e.g., they take too much time working on a separate branch and only after days of work they apply the changes in the master branch). Practitioners have baptized the bad practice of working in silos—either in their local branches or remote branches—as ‘‘Continuous Isolation’’.&lt;br /&gt;
&lt;strong&gt;Answer.&lt;/strong&gt; We empirically defined the value of our metrics for infrequent commits as 2.36 commits per weekday. We then found that 60% of the studied projects have less than 2.36 commits, suffering from infrequent commits. The size of the project has no influence on the (in)frequency of commits. Large Ruby projects, however, are the most active ones and do not adhere to this rule.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RQ2: How common is running a build with poor test coverage?&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Rationale.&lt;/strong&gt; Test coverage measures how much of a software project is exercised during testing. If a project has a fragile test suite (and consequently a low test coverage), new changes that clearly introduce bugs are potentially not caught during build time. Therefore, CI systems offer little help in software projects that do not carefully build their testing arsenal. Although many criteria were introduced to measure code coverage, roughly speaking, test coverage is measured by the number of lines of code exercised by test cases divided by the total number of lines of code.&lt;br /&gt;
&lt;strong&gt;Answer.&lt;/strong&gt;  We found 51 projects in our dataset that have records on &lt;a href=&quot;https://coveralls.io/&quot;&gt;Coveralls&lt;/a&gt;. Although the overall coverage was 78%, the coverage of Java and Ruby projects differs greatly. The average code coverage of Ruby projects was 86%, whilst for Java projects it was 63%. This suggests that although poor test coverage exist, a significant number of studied projects take care of their code coverage.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RQ3. How common is allowing the build to stay broken for long periods?&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Rationale.&lt;/strong&gt; Here we sought to investigate how common and how long broken builds stay broken in our dataset. A broken master is particularly undesirable because it may block features from rolling out (i.e., a faulty commit needs to be detected and rolled backed). Notable practitioners, such as &lt;a href=&quot;https://www.martinfowler.com/articles/continuousIntegration.html&quot;&gt;Martin Fowler&lt;/a&gt;, have suggested that ‘‘if the mainline build fails, it needs to be fixed right away’’, making a broken build an urgent, high priority task. However, if broken builds stay red longer than this, it may suggest that projects maintainers may not be taking into account the build status and, perhaps, releasing software with bugs. Still, if developers work on a faulty master, their productivity may get hampered substantially.&lt;br /&gt;
&lt;strong&gt;Answer.&lt;/strong&gt; We observed that 85% of the analyzed projects have at least one build that took more than four days to be fixed. This finding is particularly unfortunate since broken builds that take several days to be fixed may introduce an additional burden (or distrust) on the development team. Interestingly, we observed that large projects (either Java or Ruby) have less instances of long to be fixed broken builds than smaller projects. These long to be fixed builds, on very small projects, are fixed, on average, in 40 days, which is strong smell of the CI theater.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RQ4. How common are long running builds?&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Rationale.&lt;/strong&gt; In this final research question, our intention is to explore how long take the builds in our dataset to process. The whole point of Continuous Integration is to provide rapid feedback. Advocates from the XP practices provide a general rule of thumb suggesting that, for most projects, 10 minutes is an expected metric. According to &lt;a href=&quot;https://www.martinfowler.com/articles/continuousIntegration.html&quot;&gt;Fowler&lt;/a&gt;, ‘‘it’s worth putting in concentrated effort to make [the ten minutes rule] happen, because every minute you reduce off the build time is a minute saved for each developer every time they commit.’‘&lt;br /&gt;
&lt;strong&gt;Answer.&lt;/strong&gt; In order to provide quick feedback, builds should be executed under 10 minutes. We found only 43 projects that do not adhere to this general rule of thumb. As an exception to this rule, we found 43 very large and complex projects, such as  the JRuby (the Ruby implementation for the Java VM) or the Facebook Presto (a distributed SQL query engine for big data), that have builds which take longer than 30 minutes. In spite of these cases, this symptom of the CI theater was hardly observed.&lt;/p&gt;

&lt;p&gt;If you want to know more about this study, you can read the preprint available &lt;a href=&quot;https://arxiv.org/abs/1907.01602&quot;&gt;here&lt;/a&gt;, and the data is also available as a Jupyter notebook &lt;a href=&quot;https://github.com/wagnernegrao/ci-analysis/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">A summary of an ESEM'19 paper</summary></entry><entry><title type="html">Tips on how to find a phd advisor</title><link href="http://localhost:4000/blog/Tips-on-how-to-find-a-phd-advisor/" rel="alternate" type="text/html" title="Tips on how to find a phd advisor" /><published>2019-05-27T00:00:00-03:00</published><updated>2019-05-27T00:00:00-03:00</updated><id>http://localhost:4000/blog/Tips-on-how-to-find-a-phd-advisor</id><content type="html" xml:base="http://localhost:4000/blog/Tips-on-how-to-find-a-phd-advisor/">&lt;p&gt;Here and there I have been asked whether or not one should apply to a PhD position. After thinking for a while in these questions, I perceived that they can be translated to a single question: “should I apply for this position at University X”. This question is obviously important, because the decision to go to University X instead of University Y can pretty much drive your PhD. For instance, if University X does not provide basic funding to cover your expenses, it would be much more difficult to finish a PhD. However, if funding is guaranteed, the decision should not be taken in terms of the place you are going, but instead with who you will be working.&lt;/p&gt;

&lt;p&gt;For sure, it will be very impressive to state in your CV that you have a degree from that top notch university. These universities may also have beautiful labs, with a lot of funding for your research. You may also have family or close relatives that live in the city that you are planning to move, and this would greatly reduce the transaction cost. However, in my rather little experience, the most important factor is your advisor. What if your advisor is a very busy person, that needs to coordinate several projects, and several people? What if your advisor is not a very friendly person? What if your advisor is planning to do some startup and now does very little research?&lt;/p&gt;

&lt;p&gt;In other words: Is it worth to work in the top CS school in the world if you advisor is not available to support you accordingly?&lt;/p&gt;

&lt;p&gt;Moreover, for many kind of research works (at least in software engineering) you may not need a multi million dollar cluster neither thousands of dollars to travel for field study. That’s awesome if you have. But if you don’t, it is not the end of the work. You can also find some very interesting research topics that you can work on your 2013 notebook.&lt;/p&gt;

&lt;p&gt;IMO, More important than this is actually an advisor that could properly guide your work. That can devote some week hours to talk to you. That trust on you. That help you.&lt;/p&gt;

&lt;p&gt;Unfortunately, it may be very hard to note these qualities in a person that you may not even know in person. Next are some tips that may give a hint along these lines.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Find his/her personal webpage&lt;/strong&gt;: This is the very first rule of thumb. If your prospective advisor does not have a webpage, he may be very, very busy. Important: webpages such as Google Scholar or DBLP are not personal webpages. The bare minimum personal webpage should clearly make available his/her email address. If one does not provide a way to others contact him/her, s/he may not want to receive your contact.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Talk to his/her former students&lt;/strong&gt;: Former students are an excellent source of information. Perhaps no one knows better than them how their former advisor works and behaves. Important: many advisors made available a list of his/her former students. This list can be available on the advisor personal webpage, or on their CVs. Cold email a bunch of former students and ask their perceptions regarding work with your prospective advisor. Many former students will be glad to help (in particular if they enjoyed the time that they worked with your prospective advisor. Moreover, there is nothing wrong to ask for an insider opinion (your prospective advisor does the same when he asks for recommendation letters).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Follow him/her in a social network&lt;/strong&gt;: As of today, Twitter is probably the de facto on line way that researchers broadly communicate with their peers. Obviously email plays a role. However, email is private and you can hardly interact with someone else who is already having a discussion. But you can do this on Twitter. If your prospective advisor has a Twitter account, follow him/her to get a glimpse about what he thinks about many things. Whenever possible, interact with him/her.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ask for an Skype meeting&lt;/strong&gt;: A short online meeting can help a lot. If you have a negative answer, this may indicate a carelessness. Even very busy/famous professors can find the time for a quick online meeting. However, before the meeting, think about 3–5 question to ask the professor. Asking questions may indicate an interest on you side. If you have no interest, why should s/he have?&lt;/p&gt;

&lt;p&gt;Good luck.&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">Look for active internet users</summary></entry><entry><title type="html">What I think about teaching</title><link href="http://localhost:4000/blog/teaching-open-source-software/" rel="alternate" type="text/html" title="What I think about teaching" /><published>2019-05-14T00:00:00-03:00</published><updated>2019-05-14T00:00:00-03:00</updated><id>http://localhost:4000/blog/teaching-open-source-software</id><content type="html" xml:base="http://localhost:4000/blog/teaching-open-source-software/">&lt;p&gt;Although I am a professor, teaching is not the part of my work that I love the
most. I do like teaching, but I do not love teaching. And when I have a heavy
teaching working, I tend to enjoy it even less. Some reasons because teaching is
just OK to me: teaching (preparing material, teaching itself, grading, etc)
takes a lot of time; we have little to no feedback (students rarely comment if
the class was amazing or terrible); students are not always
engaged with the class, etc.&lt;/p&gt;

&lt;p&gt;I have tried some approaches to try to improve students’ engagement, but this
blog post is not about this.&lt;/p&gt;

&lt;p&gt;When I was a student, I liked to participate in meetups and local conferences to
give talks. The act of be in the front of several people (probably more skilled
and experienced than me), teaching than something new, was vibrant to me.
I loved that feeling. As a consequence,
I tried my best to give a good presentation. I read books about how to give a talk.
I attend a course on how to speak in public. I practice the talk many, many times
before delivering the talk.  I liked not only giving the talk itself,
but the process to prepare the talk (working on the slides, thinking about the
best words, looking for good figures, etc). I could easily spent many hours working
on a single talk that I could deliver in 20 minutes or less. And this made completely
sense to me.&lt;/p&gt;

&lt;p&gt;However, when I am preparing the classes material, I tried my best to do that
as fast as possible. Not fast to the point to have a crap material, but also far
from having a perfect material. If I could grade my classes material, I may give
six or even five in a scale from zero to ten. It is true that I do not have the
same amount of free time available that I had when I as a student, so
obviously, I could not employ many hours to create the materials for a single class.
Then I could naively lie to myself thinking that my classes materials are not
great because I do not have the time to curate the materials. However, even if I
had the time, I believe I would not make much progress to improve its quality.&lt;/p&gt;

&lt;p&gt;However, when it comes to delivering the lecture, there is a whole new figure.
I still enjoy a lot being in the front of a room explaining things, over and over again.
I try my best to give a good lecture. I try my best to show to student how
beautiful and exciting is one given concept. But that is it. After the lecture,
I still have to grade exams, create or improve the materials, prepare exercises,
and so on. And all of this is just boring to me.&lt;/p&gt;

&lt;p&gt;And that was true till this semester.&lt;/p&gt;

&lt;p&gt;This semester I am teaching Open Source Software Development.&lt;/p&gt;

&lt;p&gt;Open source software is something that interest me a lot. During my early days
in my undergrad course, I was an intern in a local internet provider. This was
a very interesting experience, mainly because it was my first contact with Linux.
I learned a lot of bash programming using vi. I also learned to set up several
network services, and I became very interested in computer network stuff. Several
colleagues of mine went to grad school to study computer network, and I had no idea
how I became a software engineering guy. I started to use Linux at home (a Brazilian
distribution called &lt;a href=&quot;https://www.hardware.com.br/kurumin/&quot;&gt;Kurumin&lt;/a&gt;), and I also
volunteered to install Linux in several places (something that today is called
“Linux Install Fest”). I did my master in a school that was all about open source.
I remember that they were very proud to state everywhere that they only had a single
Windows machine because of a CAPES requirement. Other than that, it was all about
Linux. Even thought I was never an active contributor (although I have contributed
here and there), I enjoy that culture. I enjoy to participate in open source
events, to discuss about open source, and to spend an afternoon trying to install
one driver.&lt;/p&gt;

&lt;p&gt;During my PhD I moved focus a bit, and did not spent much time with open source.&lt;/p&gt;

&lt;p&gt;After my PhD, I became again involved with open source, but now on the
research side. The research works that I did with open source projects and
communities seemed to be more
aligned with the industry practice, which was something that I was very concerned about.
It suddently became my main research topic; the literature that I am more
familiar with. For me, it is easy to talk about open source.&lt;/p&gt;

&lt;p&gt;I was luck to have a colleague in my university that shares the same passion
about open source that I had. This colleague is not an open source researcher;
instead, he is an active open source hacker. He does the things that I study.
He has the practice that I describe in my research papers. The next logical step
was obviously to create this open source development course.&lt;/p&gt;

&lt;p&gt;The experience I had building this course was completely different than any other course
I created. First because I started to create the material many months before the
course. Second because I reread many of the fundamental books in this discipline
(e.g., the cathedral and the bazaar). Third because I look forward to the class.
Needless to say that I enjoy very much give the lecture.&lt;/p&gt;

&lt;p&gt;This might be obvious to the reader, but it only became clear to me lately:
I like teaching this course because it is about something that I enjoy a lot.
I do enjoy learning about data structures or databases, but I do not have very interesting experiences
with them (other than using them to create ordinary software). I also do not do
research on these topics. I am also not that familiar with the fundamental books
nor the newest literature. I teach these courses because I have to teach.&lt;/p&gt;

&lt;p&gt;Lesson learned? Try to teach the subject that you like the most. If
that is not possible, try to expand your research interests to cover the
disciplines that you are teaching.&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">and how to enjoy it more</summary></entry><entry><title type="html">Why blogging in academia is important</title><link href="http://localhost:4000/blog/why-blogging-is-important/" rel="alternate" type="text/html" title="Why blogging in academia is important" /><published>2019-04-29T00:00:00-03:00</published><updated>2019-04-29T00:00:00-03:00</updated><id>http://localhost:4000/blog/why-blogging-is-important</id><content type="html" xml:base="http://localhost:4000/blog/why-blogging-is-important/">&lt;p&gt;Researchers are busy people. We always have many things to do, and we often
delay in delivering our projects. How many times did you receive an email that
started with “sorry for this late response”, or perhaps an email that was not
even answered? This behavior is so normal in academia that we do not think this
is strange anymore.&lt;/p&gt;

&lt;p&gt;Since we are so deeply involved in our projects, we have little to no time to
take care of side projects that may not lead you to that tenure that you often
dream about. More concretely, if the project does not help a researcher to improve her metrics,
such as number of citations or number of publications, chances are that this
project may be delayed, or even abandoned. This is why blogging in academia is
so hard. Because blogging will not help you to get tenure, to get that paper
accepted, or to help your research be funded. On the contrary, blog will take
away that precious time that you could invest in things that will, indeed, improve
your performance counters.&lt;/p&gt;

&lt;p&gt;However, blogging in academia is extremely important. Think about that researcher
that you admire the work she does. How cool would be if she would write blog
posts describing the process that she use to find new ideas, or how she hire students,&lt;br /&gt;
or how to deal with their problems, what she does to recover from paper deadlines,
what she thinks about conferences, journals, etc. When you blog, you let people
know more about not only your work, but also you. These conversations are, however,
natural in conferences. But if you blog, you help someone that does not have
funding to attend a conference. When you blog, you also spread your voice to
many more people than you could reach in a conference. Think you as a young
student. How amazing it would be to see yourself facing the same problems
(or perhaps conceiving the same ideas) that a well known researcher,
with many more years of experience, in that top university, also face. We are
all human, we all face problems. But blogging makes it transparent.&lt;/p&gt;

&lt;p&gt;Blogging is also a tech transfer channel. Since blog posts are shorter than most
academic research papers, readers can read all your blog posts in a small amount
of time, and then could get a much better perception about the kind of work you
like to do. None of this could be accomplished  with research papers solely (OK, you
can learn about ones work while reading his papers, but it would take much,
much  more time). Blogging can also spread your findings faster. Say, instead
of sharing your beautiful research paper with practitioners, why don’t you write
a blog post summarizing the key findings, and share these findings (in a much
better format) with them? Blogging can also help you to improve your writing
skills, which is particularly valuable for those (like me) who are not from
English speaking countries.&lt;/p&gt;

&lt;p&gt;The paradox: I know that blogging is important and I do really want to blog more.
However, blogging tasks a good amount of time that I could use to work or to stay
with my family. &lt;strong&gt;To keep blogging, however,, I made a deal with myself: I will not revise any of
my blog posts&lt;/strong&gt;. That is, after I am done with what I consider the first draft,
I will post it immediately. I took
this decision because revising and editing could take as much as or even more time
than the first draft itself. For instance, if I need one hour to write one blog post, it would actually
mean two hours, at least: one for writing, one for revising.&lt;/p&gt;

&lt;p&gt;I am aware that many
posts here have typos and strange wording. But I believe it is better to have
blog posts with writing issues rather than no blog post. Although not polished,
I think these blog posts serve their proposes: which is to communicate.&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">or why these posts have typos?</summary></entry><entry><title type="html">Changing roles in the academic system</title><link href="http://localhost:4000/blog/changing-roles-academic-system/" rel="alternate" type="text/html" title="Changing roles in the academic system" /><published>2019-04-11T00:00:00-03:00</published><updated>2019-04-11T00:00:00-03:00</updated><id>http://localhost:4000/blog/changing-roles-academic-system</id><content type="html" xml:base="http://localhost:4000/blog/changing-roles-academic-system/">&lt;p&gt;I have been reflecting on the roles that I took in academia over these last 10+
years and I finally decided to write them down. I believe I have passed through at
least four different roles in the academic system. These roles are informal and
they only exist in my mind. I may have spent 3–4 years in
each role. The roles follow a very sequential process: you only pass to the
next one when you pretty much understand the current one. Interestingly, there
is no one that says that you should pass thought all these roles, in this order.
They just happen to happen to be like this. At least it happened to me.&lt;/p&gt;

&lt;p&gt;The roles are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Understanding what is research&lt;/li&gt;
  &lt;li&gt;Learning how to do research&lt;/li&gt;
  &lt;li&gt;Conceiving research questions&lt;/li&gt;
  &lt;li&gt;Helping other to do research&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Although I worked in several tech companies during my undergraduate studies,
I did not have an opportunity to experience research.
Therefore, I only started to scratch the research world in my masters. I started
my masters in 2008 and finished in 2010, so I that I played my first academic
role (&lt;strong&gt;understanding what is research&lt;/strong&gt;) during this time window. In this particular
role, my main obligation was to understand what research is all about. Since I had zero
research experience, but reasonable industry experience, I had that feeling that
research as about creating software (eg, if I create a software that does X, I
would be able to graduate). I remember my former advisor telling me that I should
work on something that the industry is not yet doing (and not doing the same thing
that industry was doing). I also remember that it was quite difficult to understand
what she meant by this (doing a thing that this great company is not doing? what?
how could this be even possible?). By that time, my comprehension about research
improved, but was still opaque. The problem that I worked during my masters was
also a kind of challenge-free, so I knew that if I could implement the stuff that
I was supposed to implement, I was good to go. For me, research was a lot of work
and little to no reward. In this sense, research was pretty much what I  experienced
in industry, not to mention the hassle of being a student with little income.&lt;/p&gt;

&lt;p&gt;I finished my masters in 2010 with this rough notion of research, and still in
2010 I get back to the industry. I nevertheless started my phd one year later,
in 2011. I have to say that I started my phd still trying to understand what is
research. I eventually figured out that research is about understanding the unknown.
It is not about creating software solely, but to create software to test hypothesis.
I do not remember how I sorted this out, but I believe it was due to the fact
that my phd advisor often asked me to do more than one research work. These works
were done in collaboration with other students and professors, and were targeting
different research topics. All of this contribute to build my research understanding.
The next logical step was to &lt;strong&gt;learn how to do research&lt;/strong&gt;. This is not to say that
I did not do research in my master. I did. However, I did not have the conscious
understanding that what I did was research. For me, it was all about engineering.
Moreover, I have to say that it was a lot of effort to understand how to do research.
Although I have published some papers here and there in the first two years of my
phd (most of them in collaboration with other students, as aforementioned), my
phd thesis was pretty much empty. My first paper related to my thesis was accepted
only in my third year. Why was that? Because it took me a really while to find a
problem. My advisor was really open about anything, but I was in charge of looking
for interesting problems to find answers to. This process of conceiving problems
turned out to be incredibly difficult. During the first 1–2 months, you dedicate
yourself to read the literature, and you figure out that you do not know anything.
After many other months of intense reading, you start to comprehend the landscape
of one very particular part of the literature. At this moment, it seems that every
interesting question already had an answer. It seems that every interesting piece
of work that worth doing is already done. This lack of comprehension of “what to
do next” is a symptom of this second role: I understood what research was about, but
I did not know how to do it. The solution now is clear: I have to ask new questions.
Ask a new question is easy. Ask a good new question is hard. Ask an unique question
is harder. Ask an unique question that could give you a phd title is even harder.&lt;/p&gt;

&lt;p&gt;I eventually I ended up with some research questions during my phd (some of them
borrowed from the literature, some other stated my by former advisor, etc), but
I believe I only started to understand how to &lt;strong&gt;conceive research questions&lt;/strong&gt;
after my phd. We can go to a bar and some hours after come back with a list of
research questions. But how do you know which one will not lead you to a dead end?
Or how do you know that this research question was not already asked in that bedrock
paper from the 80s? How do you know reviewers will care about this research question?
Will readers care about this research question 10 years from now? Will you care
to finish a research paper that has this particular research question? There are
many other questions related to the importance of the research question. And to
conceive good research questions, you should care about these other questions.
Every single time. One may say: “yo, I can write a paper without thinking too
much about research questions”. Yes, of course you can do. In particular if you
are working on a subject that you know a lot (you know the open questions). You
can also read the “future work” section of the most important papers in your area
to easily grasp other research questions. However, one key aspect of conceiving
research questions is to find something that &lt;strong&gt;&lt;em&gt;you&lt;/em&gt;&lt;/strong&gt; would love to do. More
importantly, regardless if the question is unique, unanswered, timely, beautiful,
etc., would you trade your precious time to find an answer to it? It is not about
finishing a masters or a phd. It is about doing work that matter (at least to you).
Ultimately: look for question that keep your eyes open, day and night.&lt;/p&gt;

&lt;p&gt;Finally, the last role, which is the one that I am pursuing now, I believe, is
about &lt;strong&gt;teaching other to do research&lt;/strong&gt;. The goal now is not to have your paper
accepted at that top conference, but, instead, helping others to have their papers
accepted as well. Since I am just starting this role, I have little to share. But
one thing that I am thinking is that: since these roles last for about 3–4 years
each, which role comes next?&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">from student to scholar and more</summary></entry><entry><title type="html">How to send a student to attend ICSE (with zero budget)</title><link href="http://localhost:4000/blog/how-to-sent-a-student-to-icse/" rel="alternate" type="text/html" title="How to send a student to attend ICSE (with zero budget)" /><published>2019-03-31T00:00:00-03:00</published><updated>2019-03-31T00:00:00-03:00</updated><id>http://localhost:4000/blog/how-to-sent-a-student-to-icse</id><content type="html" xml:base="http://localhost:4000/blog/how-to-sent-a-student-to-icse/">&lt;p&gt;This year, an undergraduate student of mine first-authored a paper in the &lt;a href=&quot;http://gustavopinto.github.io/lost+found/msr2019c.pdf&quot;&gt;MSR
challenge track&lt;/a&gt; on the
presence of violations in JavaScript code snippets available on StackOverflow.
This blog post is an attempt to summarize all the steps taken to find a way
to send the student to attend the conference (and present his paper). Perhaps
it could help some other students to make it to ICSE.&lt;/p&gt;

&lt;p&gt;Overall, my student applied to four sources of funding: the &lt;a href=&quot;https://2019.icse-conferences.org/track/icse-2019-Student-Volunteers&quot;&gt;student volunteers&lt;/a&gt;, the
&lt;a href=&quot;https://2019.icse-conferences.org/track/icse-2019-Software-Engineering-Mentoring-Workshop&quot;&gt;Software Engineering Mentoring Workshop (SMeW)&lt;/a&gt;, the &lt;a href=&quot;https://www.sigsoft.org/resources/caps.html&quot;&gt;CAPS SIGSOFT&lt;/a&gt; grant, and an internal grant in my
university. I will detail each one of them next.&lt;/p&gt;

&lt;p&gt;As far as I can tell, the student volunteer program happens every single year in
ICSE (and also happens in several other software engineering conferences, such as
ICSME and ASE). In ICSE, an accepted student volunteer receives a free registration
for the main conference, but could also be scheduled to work in the co-located
events (granting one-two more registration days). Therefore, applying for student
volunteer greatly reduces one of the most costly part of attending a conference:
the conference registration. Besides of it, students volunteers also have an unique
opportunity to meet senior researchers that run the student volunteer program,
and also other students (which could ended up in new research opportunities).
I myself participated as a student volunteer in three conferences (2 OOPSLAs and
one ICSE); I could not recommend more.&lt;/p&gt;

&lt;p&gt;Moreover, this year there is the Software Engineering Mentoring Workshop. This
workshop is intended to “attract students to research careers in software engineering”.
I believe this was the first time that this workshop happened in ICSE, although
similar workshops happen on regular basis on programming language conferences
(e.g. &lt;a href=&quot;https://pldi19.sigplan.org/home/PLMW-PLDI-2019&quot;&gt;PLMW&lt;/a&gt;). My student applied
for this grant and received CAD 500,00 plus one day ICSE registration. But since
he received a free ICSE registration for his work as a student volunteer, this
one day registration was not used. Now he had enough for registration and hotel.&lt;/p&gt;

&lt;p&gt;Since he had a MSR paper, and was accepted for the mentoring workshop, he applied
for the CAPS funding. CAPS offer support for students and professionals that need
additional funding to attend SIGSOFT conferences. I have applied to this grant in
the past, but since I had received no response for my application, I thought that
this grant was not working. But I suggest my student to apply to it nevertheless.
I also discussed this matter on twitter (read thread &lt;a href=&quot;https://twitter.com/gustavopinto/status/1104505538732351490&quot;&gt;here&lt;/a&gt;), and Thomas Zimmermann, SIGSOFT Chair, responded that he would take care of the
CAPS program. Turns our that my student received USD 400,00 from CAPS (about 50%
of what he asked for). Although this amount does not fully cover a round trip
ticket from Belém to Montreal, it amortizes a good proportion of it.&lt;/p&gt;

&lt;p&gt;Finally, I applied for him in an internal travel grant that my university runs
for undergraduate students. The amount was fixed in around USD 330. Although
this is a very particular grant from my university, I am aware that other
Brazilian universities provide similar mechanism to help students. Now his trip
is fully covered (including eventual meals, ground transportation, travel
insurance, etc).&lt;/p&gt;

&lt;p&gt;Wrapping up, I am glad that there are many international grants aimed to
help students to attend software engineering conferences. But the trick thing is:
if one of these grants does not have a positive outcome, I would have to complement
his trip out of my own pocket (although I have a small grant running, I could not
use this grant to support his trip; I will leave this explanation for another blog post).
If his application was not accepted in two or more grants, his trip would become
extremely prohibitive. Still, these grants have different application dates
(and, consequently, notification dates). So eventually the student find himself in a
position such as: (1) what if I accept this grant but did not receive the other one?
(2) Could I say “yes” for a grant but eventually say “no” to it due to the lack of
additional support? (3) should I start making reservations, or should I leave it
to the last minute (when tickets often become more expensive)?
These questions are all valid and tough.&lt;/p&gt;

&lt;p&gt;Turn out that the stars in the sky were well aligned the applications were all
positive. Reflection upon this endeavour, maybe it would be interesting if all
these programs would have close notification dates to each other.&lt;/p&gt;

&lt;p&gt;Final tip: the &lt;a href=&quot;https://2019.icse-conferences.org/track/icse-2019-ACM-Student-Research#Call-for-Contributions&quot;&gt;ACM Student Research Competition&lt;/a&gt; also rewards the students with accepted papers
with up to USD 500,00 to help them defray their travel costs. My student did not
submit to ACM SRC (I may have forgotten; this blog post can help even myself in
the future).&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">Apply for every single opportunity (and cross your fingers)</summary></entry><entry><title type="html">Characterizing the Roles of Contributors in Scientific OSS Projects</title><link href="http://localhost:4000/blog/characterizing-the-roles-of-contributors-in-scientific-oss-projects/" rel="alternate" type="text/html" title="Characterizing the Roles of Contributors in Scientific OSS Projects" /><published>2019-03-05T00:00:00-03:00</published><updated>2019-03-05T00:00:00-03:00</updated><id>http://localhost:4000/blog/characterizing-the-roles-of-contributors-in-scientific-oss-projects</id><content type="html" xml:base="http://localhost:4000/blog/characterizing-the-roles-of-contributors-in-scientific-oss-projects/">&lt;p&gt;Recently some colleagues and I have been trying to understand the roles of contributors in open source scientific software projects. We studied 7 well-known scientific software projects that were hosted on GitHub (including &lt;a href=&quot;https://github.com/Chaste/Chaste&quot;&gt;Chaste&lt;/a&gt;, &lt;a href=&quot;https://github.com/dib-lab/khmer/&quot;&gt;Khmer&lt;/a&gt;, and &lt;a href=&quot;https://github.com/genn-team/genn&quot;&gt;Genn&lt;/a&gt;). For each selected project, we identified the roles played by different contributors by analyzing each projects’ documentation, websites, and other readily available sources. Using a mix of quantitative and qualitative data, we curate some findings that we believe are interesting for the broad Medium population. Here they are.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Senior researchers tend to be the most active and prolific contributors in terms of commits and file creation.&lt;/strong&gt; In four of the seven projects we studied, faculty and staff contributors were responsible for half or more of commits made to the project (with an average commit share of 72%). In five projects, senior members were also responsible for the majority of files created and, by that measure, the resulting project structure. This influence over the overall direction of the software project was also evident in the fact that senior researchers were the most likely to have interacted with files related to the build system, project metadata, and developer documentation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Junior contributors, especially graduate students, are critical drivers of new features as well as supporting activities like test creation.&lt;/strong&gt; On average, junior contributors were responsible for 42% of commits across all projects we studied; in one case, juniors were responsible for nearly 100% of all commit activity. The majority of these commits came from graduate students, who had the longest contribution periods among juniors (with 1.72 years of commit activity compared to 0.98 years for postdocs and 4 months for undergraduates). Similar to senior contributors, junior contributors are significantly involved in creating new features, improving existing capabilities, and fixing bugs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;An open-source model facilitates external contributions, but the results are mixed.&lt;/strong&gt; On one hand, an open- source model makes it easier to attract third parties to help grow and maintain the software. However, the software is also made for and by members of a relatively niche and intensely preoccupied community. In the majority of projects we studied, third party contributors tended to be domain expert users who were only active for one day. We also note, however, that these same contributors are more likely to offer defect-correcting commits, which is highly valuable.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to know more about this study, you can read the preprint &lt;a href=&quot;http://gustavopinto.github.io/lost+found/msr2019b.pdf&quot;&gt;available here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Gustavo Pinto</name><email>gpinto@ufpa.br</email><uri>http://www.gustavopinto.org</uri></author><summary type="html">A summary of a MSR'19 paper</summary></entry></feed>